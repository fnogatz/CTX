<?xml version="1.0" encoding="UTF-8" ?>

<xs:schema
		targetNamespace="http://ctx.chess.io"
		xmlns="http://ctx.chess.io"
		version="1.0.0"
		elementFormDefault="unqualified"
		xmlns:xs="http://www.w3.org/2001/XMLSchema"
		xmlns:xerces="http://xerces.apache.org"
		xmlns:teamTournament="http://ctx.chess.io/Team-Tournament"
		xmlns:individualTournament="http://ctx.chess.io/Individual-Tournament"
		xmlns:contact="http://ctx.chess.io/Contact"
		xmlns:person="http://ctx.chess.io/Person"
		xmlns:rating="http://ctx.chess.io/Rating">

	<xs:annotation>
		<xs:documentation xml:lang="EN">
			Basic CTX Schema for both Individual and Team Tournaments.
		</xs:documentation>
	</xs:annotation>

	<xs:import namespace="http://ctx.chess.io/Individual-Tournament" schemaLocation="Individual-Tournament.xsd" />
	<xs:import namespace="http://ctx.chess.io/Team-Tournament" schemaLocation="Team-Tournament.xsd" />
	<xs:import namespace="http://ctx.chess.io/Contact" schemaLocation="Contact.xsd" />
	<xs:import namespace="http://ctx.chess.io/Person" schemaLocation="Person.xsd" />
	<xs:import namespace="http://ctx.chess.io/Rating" schemaLocation="Rating.xsd" />

	<xs:element name="tournament" type="tournament">
		<xs:alternative test="@type = 'individual'" type="individualTournament:tournament" />
		<xs:alternative test="@type = 'team'" type="teamTournament:tournament" />

		<xs:key name="player-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Index über die Spieler-IDs in /tournament/players/player/@id
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="players/player" />
			<xs:field xpath="@id" />
		</xs:key>

		<xs:keyref name="player-id-keyref" refer="player-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Keyref: Die in /tournament/teams/team/players/player genannte @id muss 
					ein player-id-key sein. Erübrigt sich bei Einzelturnieren.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="teams/team/players/player" />
			<xs:field xpath="@id" />
		</xs:keyref>

		<xs:keyref name="_s_player-pairing-keyref" refer="player-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Keyref: Die in
					/tournament/pairings/round/boards/board/{white,black},
					/tournament/pairings/round/boards/board/player,
					/tournament/pairings/round/boards/board/games/game/{white,black}
					genannte @player ID muss ein player-id-key sein. Erübrigt sich bei Mannschaftsturnieren.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="pairings/round/boards/board/white
												| pairings/round/boards/board/black
												|	pairings/round/boards/board/player
												| pairings/round/boards/board/games/game/white
												| pairings/round/boards/board/games/game/black
												| pairings/inning/rounds/round/boards/board/white
												| pairings/inning/rounds/round/boards/board/black
												| pairings/inning/rounds/round/boards/board/player
												| pairings/inning/rounds/round/boards/board/games/game/white
												| pairings/inning/rounds/round/boards/board/games/game/black
												" />
			<xs:field xpath="@player | @id" />
		</xs:keyref>

		<xs:keyref name="_s_player-rankings-initial-keyref" refer="player-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Keyref: Die in /tournament/rankings/initial/player genannte @id muss ein 
					player-id-key sein. Erübrigt sich bei Mannschaftsturnieren.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="rankings/initial/player" />
			<xs:field xpath="@id" />
		</xs:keyref>

		<xs:keyref name="_t_player-pairing-keyref" refer="player-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Keyref: Die in /tournament/pairings/round/tables/table/boards/board/{white,black}
					genannte @player ID muss ein player-id-key sein. Erübrigt sich bei Einzelturnieren.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="pairings/round/tables/table/boards/board/white
												| pairings/round/tables/table/boards/board/black
												| pairings/round/tables/table/boards/board/player
												| pairings/round/tables/table/boards/board/games/game/white
												| pairings/round/tables/table/boards/board/games/game/black
												| pairings/inning/rounds/round/tables/table/boards/board/white
												| pairings/inning/rounds/round/tables/table/boards/board/black
												| pairings/inning/rounds/round/tables/table/boards/board/player
												| pairings/inning/rounds/round/tables/table/boards/board/games/game/white
												| pairings/inning/rounds/round/tables/table/boards/board/games/game/black
												" />
			<xs:field xpath="@player | @id" />
		</xs:keyref>

		<xs:keyref name="_s_settings-pairings-constraints-player-keyref" refer="player-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Keyref: Die in /tournament/settings/pairings/constraints/players/player
					genannte @id muss ein player-id-key sein.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="settings/pairings/constraints/players/player" />
			<xs:field xpath="@id" />
		</xs:keyref>


		<xs:unique name="unique-player-fide-id">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Die /tournament/players/player/identifiers/fide/id muss eindeutig sein.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="players/player/identifiers/fide" />
			<xs:field xpath="id" />
		</xs:unique>

		<xs:unique name="unique-player-federation-id">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Die in /tournament/players/player/identifiers/federation 
					genannte (@code, id) Kombination muss eindeutig sein.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="players/player/identifiers/federation" />
			<xs:field xpath="@code" />
			<xs:field xpath="id" />
		</xs:unique>

		<xs:unique name="unique-player-club-id-member">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Die in /tournament/players/player/identifiers/club
					geführten Tripel (@federation, id, member-id)
					müssen eindeutig sein.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="players/player/identifiers/club" />
			<xs:field xpath="@federation" />
			<xs:field xpath="id" />
			<xs:field xpath="member-id" />
		</xs:unique>

		<xs:unique name="unique-team-federation-team-number">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Die in /tournament/teams/team/identifiers/federation
					geführten Paare (@code, team-number)
					müssen eindeutig sein.
					Die Landesauswahlen müssen also unterschiedlich nummeriert
					sein.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="teams/team/identifiers/federation" />
			<xs:field xpath="@code" />
			<xs:field xpath="team-number" />
		</xs:unique>

		<xs:unique name="unique-team-club-team-number">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Die in /tournament/teams/team/identifiers/club
					geführten Paare (name, team-number)
					müssen eindeutig sein.
					Mehrere Mannschaften eines Vereins müssen also 
					unterschiedlich nummeriert sein.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="teams/team/identifiers/club" />
			<xs:field xpath="name" />
			<xs:field xpath="team-number" />
		</xs:unique>


		<xs:key name="team-id-key">
			<xs:selector xpath="teams/team" />
			<xs:field xpath="@id" />
		</xs:key>

		<xs:keyref name="_t_team-rankings-initial-keyref" refer="team-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					[Mannschaftsturnier]
					Keyref: Die in /tournament/rankings/initial/team genannte @id muss ein 
					team-id-key sein. Erübrigt sich bei Einzelturnieren.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="rankings/initial/team" />
			<xs:field xpath="@id" />
		</xs:keyref>


		<xs:key name="round-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Index über die Rundennummern in /tournament/pairings/round/@number
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="pairings/round" />
			<xs:field xpath="@number" />
		</xs:key>

		<xs:key name="inning-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Index über die Durchgänge in /tournament/pairings/inning/@number
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="pairings/inning" />
			<xs:field xpath="@number" />
		</xs:key>

		
		<xs:key name="team-location-key">
			<xs:selector xpath="teams/team/locations/location" />
			<xs:field xpath="@id" />
		</xs:key>
		
		<xs:keyref name="team-location-keyref" refer="team-location-key">
			<xs:selector xpath="pairings/round/tables/table/information/host
												| pairings/inning/rounds/round/tables/table/information/host
												" />
			<xs:field xpath="@location" />
		</xs:keyref>

		<xs:keyref name="team-location-team-keyref" refer="team-id-key">
			<xs:selector xpath="pairings/round/tables/table/information/host
												| pairings/inning/rounds/round/tables/table/information/host
												" />
			<xs:field xpath="@team" />
		</xs:keyref>

		<xs:keyref name="_t_team-pairing-keyref" refer="team-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Keyref: Die in /tournament/pairings//round/tables/table/team 
					genannte @id muss ein team-id-key sein. Erübrigt sich bei Einzelturnieren.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="pairings/round/tables/table/team
												| pairings/inning/rounds/round/tables/table/team
												" />
			<xs:field xpath="@id" />
		</xs:keyref>

		<xs:keyref name="_t_team-pairing-boards-keyref" refer="team-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Keyref: Die in /tournament/pairings//round/tables/table/boards/board/{white,black,player}/@team
					genannte Team-ID muss ein team-id-key sein. Erübrigt sich bei Einzelturnieren.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="pairings/round/tables/table/boards/board/white 
												| pairings/round/tables/table/boards/board/black
												| pairings/round/tables/table/boards/board/player
												| pairings/inning/rounds/round/tables/table/boards/board/white
												| pairings/inning/rounds/round/tables/table/boards/board/black
												| pairings/inning/rounds/round/tables/table/boards/board/player
												" />
			<xs:field xpath="@team" />
		</xs:keyref>


		<xs:key name="arbiter-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Index über die Schiedsrichter-IDs in /tournament/information/arbiters/arbiter/@id
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="information/arbiters/arbiter" />
			<xs:field xpath="@id" />
		</xs:key>

		<xs:keyref name="team-pairings-arbiter-keyref" refer="arbiter-id-key">
			<xs:selector xpath="pairings/round/tables/table/information/arbiters/arbiter
												| pairings/inning/rounds/round/tables/table/information/arbiters/arbiter
												" />
			<xs:field xpath="@id" />
		</xs:keyref>
	</xs:element>

	<xs:complexType name="tournament">
		<xs:all>
 			<xs:element name="information" type="information" />

			<xs:element name="players" type="players" />
		</xs:all>

		<xs:attribute name="type" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="team" />
					<xs:enumeration value="individual" />
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>

		<xs:assert
			test="every $p in players/player/birth-year satisfies (xs:int($p) le xs:int(year-from-date(information/date/start)))"
			xerces:message="Every player's birth year must be before the tournament's starting date." />

		<xs:assert
			test="every $p in players/player/birth satisfies ($p lt information/date/start)"
			xerces:message="Every player's birth must be before the tournament's starting date." />

		<xs:assert
			test="every $date in pairings//information/date satisfies ($date le information/date/end)"
			xerces:message="Round date must be before tournament's ending date.">
			<xs:annotation>
				<xs:documentation xml:lang="EN">
					Round date must be before tournament's ending date.
					Note: There's no assertion to check if the rounds were played
					in the right order, i.e. it MAY NOT
					pairings/round[$i+n]/information/date >= pairings/round[$i]/information/date
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert
			test="every $date in pairings//information/date satisfies ($date ge information/date/start)"
			xerces:message="Round date must be after tournament's starting date.">
			<xs:annotation>
				<xs:documentation xml:lang="EN">
					Round date must be after tournament's starting date.
					Note: There's no assertion to check if the rounds were played
					in the right order, i.e. it MAY NOT
					pairings/round[$i+n]/information/date >= pairings/round[$i]/information/date
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert
			test="if (
											(count(settings/pairings/system[@type eq 'Round-Robin']) eq 0) or 
											(count(settings/pairings/system[@type eq 'Round-Robin']/innings) eq 0) or
											(xs:integer(settings/pairings/system[@type eq 'Round-Robin']/innings) eq 1)
										) then (
											count(pairings/inning) eq 0
										) else (
											count(pairings/round) eq 0
										)"
			xerces:message="If it is a Round-Robin Tournament, i.e. /tournament/settings/system/@type = 'Round-Robin', and more than one inning is played, i.e. /tournament/settings/system/innings > 1, the child-nodes of /tournament/pairings must be 'inning'. Otherwise /tournament/pairings has to include 'round' elements." />

		<xs:assert
			test="if (
											(count(settings/pairings/system[@type eq 'Round-Robin']) eq 0) or 
											(count(settings/pairings/system[@type eq 'Round-Robin']/innings) eq 0) or
											(xs:integer(settings/pairings/system[@type eq 'Round-Robin']/innings) eq 1)
										) then (
											count(rankings/innings) eq 0
										) else (
											count(rankings/rounds) eq 0
										)"
			xerces:message="If it is a Round-Robin Tournament, i.e. /tournament/settings/system/@type = 'Round-Robin', and more than one inning is played, i.e. /tournament/settings/system/innings > 1, there must not be an /tournament/rankings/innings element instead of /tournament/rankings/rounds. Tournaments with only one inning must not have any 'innings' element within /tournament/rankings." />

		<xs:assert
			test="if (
											(count(settings/pairings/system[@type eq 'Round-Robin']) eq 0) or 
											(count(settings/pairings/system[@type eq 'Round-Robin']/innings) eq 0) or
											(xs:integer(settings/pairings/system[@type eq 'Round-Robin']/innings) eq 1)
										) then (
											true()
										) else (
											every $inningno in rankings/innings/inning/@number satisfies ($inningno le settings/pairings/system[@type eq 'Round-Robin']/innings)
										)"
			xerces:message="If it is a Round-Robin Tournament, i.e. /tournament/settings/system/@type = 'Round-Robin', and more than one inning is played, i.e. /tournament/settings/system/innings > 1, the inning/@number in /tournament/rankings/inning must be less or equal to the specified number of innings in /tournament/settings/pairings/system/innings." />

		<xs:assert
			test="(count(settings/general/games-per-round) eq 0) or (settings/general/games-per-round eq 1) or count(pairings//board/(white | black)) eq 0"
			xerces:message="If multiple games are played per round, i.e. /tournament/settings/general/games-per-round is set and greater than 1, the competing players of each board must be referenced through the 'player' element and not by 'white' and 'black'." />

		<xs:assert
			test="if (
											(count(settings/general/games-per-round) eq 0) or
											(settings/general/games-per-round eq 1)
										) then (
											count(pairings//board/games/game) eq 0
										) else (
											true()
										)"
			xerces:message="If only one game is played per round, i.e. /tournament/settings/general/games-per-round is either not set or equal to 1, no 'games' element is allowed within a 'board' element in /tournament/pairings/(...)." />

		<xs:assert
			test="if (
						(count(settings/general/games-per-round) eq 0) or
						(settings/general/games-per-round eq 1)
					) then (
						true()
					) else (
						every $games in pairings//board/games satisfies (
							count($games/game) eq xs:integer(settings/general/games-per-round)
						)
					)"
			xerces:message="If multiple games are played per round, i.e. /tournament/settings/general/games-per-round > 1, the number of 'game' elements in /tournament/pairings/(...)/board/games must be equal to this one specified in /tournament/settings/general/games-per-round." />

		<xs:assert
			test="if (
						(count(settings/general/games-per-round) eq 0) or
						(settings/general/games-per-round eq 1)
					) then (
						true()
					) else (
						every $results in pairings//board/results/player satisfies (
							sum($results/*) le settings/general/games-per-round
						)
					)"
			xerces:message="If more than one game is played per round, i.e. /tournament/settings/general/games-per-round > 1, the number of results in /tournament/pairings/(...)/board/results/player must be less or equal to the number of games specified in /tournament/settings/general/games-per-round." />

		<xs:assert
			test="every $roundno in pairings//round/@number satisfies ($roundno le settings/general/rounds)"
			xerces:message="Every round number in /tournament/pairings//round/@number must be less or equal to the specified one in /tournament/settings/general/rounds." />

		<xs:assert
			test="every $roundno in rankings//rounds/round/@number satisfies ($roundno le settings/general/rounds)"
			xerces:message="Every round number in /tournament/rankings//round/@number must be less or equal to the specified one in /tournament/settings/general/rounds." />

		<xs:assert
			test="if (count(pairings/inning) gt 0) then (
					every $round in pairings/inning/rounds/round[boards or tables]/@number satisfies (
						count(pairings/inning/rounds/round[@number eq $round][boards or tables]) eq settings/pairings/system[@type eq 'Round-Robin']/innings
					)
				) else (true())"
			xerces:message="The pairings of an already paired round must be specified in every inning." />

		<xs:assert
			test="(every $roundno in rankings/rounds/round/@number satisfies (
						count(pairings/round[@number eq $roundno][boards or tables]) gt 0
					)) and
						(every $inningno in rankings/innings/inning/@number satisfies (
							every $roundno in rankings/innings/inning[@number eq $inningno]/rounds/round/@number satisfies (
								count(pairings/inning[@number eq $inningno]/rounds/round[@number eq $roundno][boards or tables]) gt 0
							)
						))"
			xerces:message="There must not be any ranking for rounds, which aren't paired yet." />

		<xs:assert
			test="every 
						$federation in distinct-values(data((players/player | teams/team)/identifiers/club/@federation)), 
						$id in distinct-values(data((players/player | teams/team)/identifiers/club[@federation eq $federation]/id))
					satisfies (
						count(distinct-values(data((players/player | teams/team)/identifiers/club[@federation eq $federation and xs:string(id) eq xs:string($id)]/name))) eq 1
					)"
			xerces:message="Clubs of the same club/@federation with the identical club/id must also have the same club/name." />

		<xs:assert
			test="every $club_name in distinct-values(data((players/player | teams/team)/identifiers/club/name)) satisfies (
						count(distinct-values(data((players/player | teams/team)/identifiers/club[xs:string(name) eq xs:string($club_name)]/@federation))) le 1
					)"
			xerces:message="Clubs with the same club/name must also have the identical club/@federation if set. Keep in mind that the Club-Name is an distinct key. If you have clubs of different federations with the same name, you have to suffix them." />

		<xs:assert
			test="every $club_name in distinct-values(data((players/player | teams/team)/identifiers/club/name)) satisfies (
											count(distinct-values(data((players/player | teams/team)/identifiers/club[xs:string(name) eq xs:string($club_name)]/id))) le 1
										)"
			xerces:message="Clubs with the same club/name must also have the identical club/id if set. Keep in mind that the Club-Name is an distinct key. If you have clubs with different IDs but the same name, you have to suffix them." />

		<xs:assert
			test="count((//@federation | //federation/@code)[string-length(xs:string(.)) eq 2]) eq 0 or count((//@federation | //federation/@code)[string-length(xs:string(.)) eq 3]) eq 0"
			xerces:message="You have to use either IOC or ISO3166 Country Codes in the complete XML file. Please do not mix both types." />
	</xs:complexType>

	<xs:complexType name="information">
		<xs:sequence>
			<xs:element name="name">
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="xs:string">
							<xs:attribute name="abbreviation" type="xs:string" use="optional" />
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>

			<xs:element name="description" type="xs:string" minOccurs="0" />

			<xs:element name="date">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="start" type="xs:date" />
						<xs:element name="end" type="xs:date" />
					</xs:sequence>

					<xs:assert
						test="start le end"
						xerces:message="Start date must be before end date" />
				</xs:complexType>
			</xs:element>

			<xs:element name="location" type="contact:location" minOccurs="0" />

			<xs:element name="time-controls" type="xs:anyType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="EN">
						Two forms allowed to specify time controls:
							* as complex type [time-controls-complex]
							* (deprecated) as string [time-controls-string]
					</xs:documentation>
				</xs:annotation>

				<xs:alternative test="if (count(@type) eq 1) then (@type eq 'string') else false()" type="time-controls-string" />
				<xs:alternative test="true()" type="time-controls-complex" />
			</xs:element>

			<xs:element name="organizers" type="xs:anyType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="EN">
						All organizers.
						Two forms allowed to specify the organizers:
							* as complex type [organizers-complex]
							* (deprecated) as string [organizers-string]
					</xs:documentation>
				</xs:annotation>

				<xs:alternative test="@type and @type eq 'string'" type="person:organizers-string" />
				<xs:alternative test="true()" type="person:organizers-list" />
			</xs:element>

			<xs:element name="arbiters" type="xs:anyType" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="EN">
						All arbiters, especially in leagues.
						Two forms allowed to specify the arbiters:
							* as complex type [arbiters-complex]
							* (deprecated) as string [arbiters-string]
					</xs:documentation>
				</xs:annotation>

				<xs:alternative test="@type and @type eq 'string'" type="person:arbiters-string" />
				<xs:alternative test="true()" type="person:arbiters-list" />
			</xs:element>

			<xs:element name="rating-versions" minOccurs="0">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="rating" maxOccurs="unbounded">
							<xs:complexType>
								<xs:simpleContent>
									<xs:extension base="xs:date">
										<xs:attribute name="type" type="rating:system" use="optional" default="" />
									</xs:extension>
								</xs:simpleContent>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>

				<xs:unique name="unique-rating-version">
					<xs:selector xpath="rating" />
					<xs:field xpath="@type" />
				</xs:unique>
			</xs:element>
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="players">
		<xs:annotation>
			<xs:documentation xml:lang="EN">
				List of all players.
			</xs:documentation>
		</xs:annotation>

		<xs:sequence>
			<xs:element name="player" type="person:player" minOccurs="0" maxOccurs="unbounded" />
		</xs:sequence>

		<xs:assert 
			test="
				every $i in 1 to count(player)-1 satisfies (
					if (player[$i]/name/@type eq 'string') then (
						if (player[$i+1]/name/@type eq 'string') then (
							compare(
								lower-case(player[$i]/name),
								lower-case(player[$i+1]/name)
							) le 0
						) else (
							compare(
								lower-case(player[$i]/name),
								lower-case(concat(player[$i+1]/name/surname, ',', player[$i+1]/name/prename, ',', player[$i+1]/name/academic-title))
							) le 0
						)
					) else (
						if (player[$i+1]/name/@type eq 'string') then (
							compare(
								lower-case(concat(player[$i]/name/surname, ',', player[$i]/name/prename, ',', player[$i]/name/academic-title)),
								lower-case(player[$i+1]/name)
							) le 0
						) else (
							compare(
								lower-case(concat(player[$i]/name/surname, ',', player[$i]/name/prename, ',', player[$i]/name/academic-title)),
								lower-case(concat(player[$i+1]/name/surname, ',', player[$i+1]/name/prename, ',', player[$i+1]/name/academic-title))
							) le 0
						)
					)
				)" 
				xerces:message="Players must be sorted by their name. Attention: Sorting depends on collation, i.e. by default 'a' lt 'z' lt 'ä' lt 'ö' lt 'ü'." />

		<xs:assert 
			test="every $i in 1 to count(player) satisfies (player[$i]/@id eq $i)" 
			xerces:message="Players must be serially numbered, beginning with 1." />
	</xs:complexType>

	<xs:complexType name="time-controls-string">
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="type" fixed="string" use="required" />
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>

	<xs:complexType name="time-controls-complex">
		<xs:sequence>
			<xs:element name="period" type="xs:anyType" minOccurs="1" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="EN">
						Allowed forms to specify time controls:
						  * as complex type [period-complex]
						  * as string (deprecated) [period-string]
					</xs:documentation>
				</xs:annotation>

				<xs:alternative test="@type and @type eq 'string'" type="period-string" />
				<xs:alternative test="true()" type="period-complex" />
			</xs:element>
		</xs:sequence>

		<xs:assert 
			test="every $i in 1 to count(period) satisfies (period[$i]/@number = $i)" 
			xerces:message="Periods must be serially numbered, beginning with 1." />

		<xs:assert 
			test="not(period[last()]/moves) or period[last()]/@type eq 'string'" 
			xerces:message="Last period must not contain a 'move' node or must be of @type='string'." />

		<xs:assert 
			test="every $i in 1 to count(period)-1 satisfies (period[$i]/moves or period[$i]/@type eq 'string')" 
			xerces:message="Every period except the last one must contain a 'move' node or must have Attribute @type='string' set." />
	</xs:complexType>

	<xs:complexType name="period-string">
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="type" fixed="string" use="required" />

				<xs:attribute name="number" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:nonNegativeInteger" />
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>

	<xs:complexType name="period-complex">
		<xs:sequence>
			<xs:element name="moves" minOccurs="0" type="xs:positiveInteger" />
			<xs:element name="time" type="simple-time" />
			<xs:element name="increment" type="simple-time" minOccurs="0" />
		</xs:sequence>

		<xs:attribute name="number" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:nonNegativeInteger" />
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="simple-time">
		<xs:simpleContent>
			<xs:extension base="xs:float">
				<xs:attribute name="unit">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="hours" />
							<xs:enumeration value="minutes" />
							<xs:enumeration value="seconds" />
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>

	<xs:simpleType name="result-attribute">
		<xs:restriction base="xs:string">
			<xs:enumeration value="by-default" />

			<xs:enumeration value="adjourned" />

			<xs:enumeration value="" />
		</xs:restriction>
	</xs:simpleType>

	<xs:simpleType name="blank">
		<xs:restriction base="xs:string">
			<xs:enumeration value="" />
		</xs:restriction>
	</xs:simpleType>

	<xs:simpleType name="color">
		<xs:restriction base="xs:string">
			<xs:enumeration value="white" />
			<xs:enumeration value="black" />
		</xs:restriction>
	</xs:simpleType>

	<xs:simpleType name="color-with-blank">
		<xs:union memberTypes="color blank" />
	</xs:simpleType>

	<xs:complexType name="notes">
		<xs:sequence>
			<xs:element name="note" minOccurs="0">
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="xs:string">
							<xs:attribute name="date" type="xs:dateTime" use="optional">
								<xs:annotation>
									<xs:documentation xml:lang="EN">
										Timestamp of last recent update.
									</xs:documentation>
								</xs:annotation>
							</xs:attribute>

							<xs:attribute name="public" type="xs:boolean" use="optional" default="false">
								<xs:annotation>
									<xs:documentation xml:lang="EN">
										Flag whether the note is public. Notes with @public='true' could be
										published in notices of pairings for example.
									</xs:documentation>
								</xs:annotation>
							</xs:attribute>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="pairing-information">
		<xs:sequence>
			<xs:sequence minOccurs="0">
				<xs:element name="date" type="xs:date" />
				<xs:element name="time" type="xs:time" minOccurs="0" />
			</xs:sequence>			
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="pairing-information_single">
		<xs:complexContent>
			<xs:extension base="pairing-information">
				<xs:sequence>
					<xs:element name="location" type="contact:location" minOccurs="0" />
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="board_abstract" abstract="true">
		<xs:annotation>
			<xs:documentation xml:lang="EN">
				Superclass for board_bye and board.
			</xs:documentation>
		</xs:annotation>

		<xs:attribute name="attribute" type="board-attribute" use="optional" default="" />
		<xs:attribute name="number" type="xs:positiveInteger" use="required" />
	</xs:complexType>

	<xs:complexType name="board_bye">
		<xs:complexContent>
			<xs:extension base="board_abstract">
				<xs:sequence>
					<xs:element name="player">
						<xs:complexType>
							<xs:attribute name="id" type="xs:positiveInteger" />
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="board-single-player">
		<xs:attribute name="player" type="xs:positiveInteger" />
	</xs:complexType>

	<xs:simpleType name="board-attribute">
		<xs:restriction base="xs:string">
			<xs:enumeration value="" />

			<xs:enumeration value="bye" />
		</xs:restriction>
	</xs:simpleType>

	<xs:complexType name="result-single">
		<xs:sequence>
			<xs:element name="white" type="board-result" />
			<xs:element name="black" type="board-result" />
		</xs:sequence>

		<xs:attribute name="attribute" type="result-attribute" use="optional" />

		<xs:attribute name="overruled" type="xs:boolean" use="optional" default="false">
			<xs:annotation>
				<xs:documentation xml:lang="EN">
					Result not longer valid as being overruled be a tournament instance
					like the arbiter.
					In this case the originally played result will be marked by the
					@overruled='true' attribute.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>

		<xs:attribute name="special" type="xs:boolean" use="optional" default="false">
			<xs:annotation>
				<xs:documentation xml:lang="EN">
					If the sum of the points of both players is not equal to 1,
					the @special='true' attribute has to be set to mark the
					special result.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>

		<xs:assert 
			test="if (not(xs:boolean(@special))) then (white + black eq 1) else true()" 
			xerces:message="Points sum equals not 1. Set @special='true' for special results." />
	</xs:complexType>

	<xs:simpleType name="board-result">
		<xs:annotation>
			<xs:documentation xml:lang="EN">
				Result of a single game (and single player).
			</xs:documentation>
		</xs:annotation>

		<xs:restriction base="xs:decimal">
			<xs:enumeration value="0" />
			<xs:enumeration value="0.5" />
			<xs:enumeration value="1" />
		</xs:restriction>
	</xs:simpleType>

	<xs:complexType name="single-result-summarization">
		<xs:simpleContent>
			<xs:extension base="xs:nonNegativeInteger">
				<xs:attribute name="attribute" type="result-attribute" use="optional" default="" />
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
</xs:schema>