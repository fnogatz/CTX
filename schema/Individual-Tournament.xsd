<xs:schema
		targetNamespace="http://ctx.chess.io/Individual-Tournament"
		xmlns="http://ctx.chess.io/Individual-Tournament"
		version="1.0.0"
		xmlns:xs="http://www.w3.org/2001/XMLSchema"
		xmlns:xerces="http://xerces.apache.org"
		xmlns:tournament="http://ctx.chess.io">

	<xs:import namespace="http://ctx.chess.io" schemaLocation="CTX.xsd" />

	<xs:complexType name="tournament">
		<xs:complexContent>
			<xs:extension base="tournament:tournament">
				<xs:all>
					<xs:element name="settings" type="settings" />

					<xs:element name="pairings" type="pairings" minOccurs="0" />

<!-- 					<xs:element name="rankings" type="rankings" minOccurs="0" /> -->
				</xs:all>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="settings">
		<xs:annotation>
			<xs:documentation xml:lang="EN">
				Tournament settings.
			</xs:documentation>
		</xs:annotation>

		<xs:all>
			<xs:element name="general">
				<xs:complexType>
					<xs:all>
						<xs:element name="rounds" type="xs:positiveInteger">
							<xs:annotation>
								<xs:documentation xml:lang="EN">
									Number of rounds.
								</xs:documentation>
							</xs:annotation>
						</xs:element>

						<xs:element name="games-per-round" type="xs:positiveInteger" minOccurs="0">
							<xs:annotation>
								<xs:documentation xml:lang="EN">
									Games per round.
									Optional. Implicitly 1.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:all>
				</xs:complexType>
			</xs:element>

			<xs:element name="points-system" type="tournament:game-points" minOccurs="0">
				<xs:unique name="s_unique-game-points-individuals_win">
					<xs:selector xpath="win" />
					<xs:field xpath="@attribute" />
					<xs:field xpath="@color" />
				</xs:unique>
				<xs:unique name="s_unique-game-points-individuals_draw">
					<xs:selector xpath="draw" />
					<xs:field xpath="@attribute" />
					<xs:field xpath="@color" />
				</xs:unique>
				<xs:unique name="s_unique-game-points-individuals_loss">
					<xs:selector xpath="loss" />
					<xs:field xpath="@attribute" />
					<xs:field xpath="@color" />
				</xs:unique>
			</xs:element>

<!-- 			<xs:element name="pairings" minOccurs="0">
				<xs:complexType>
					<xs:all>
						<xs:element name="system" type="_s_pairings-system" minOccurs="0">
							<xs:alternative type="_s_pairings-system-Swiss" test="@type eq 'Swiss'" />
							<xs:alternative type="_s_pairings-system-Round-Robin" test="@type eq 'Round-Robin'" />
						</xs:element>

						<xs:element name="constraints" minOccurs="0">
							<xs:annotation>
								<xs:documentation xml:lang="EN">
									Randbedingungen zur Ermittlung der Paarungen, etwa
									feste Brettnummern oder Angabe der Runden, in denen
									einzelne Spieler aussetzen.
								</xs:documentation>
							</xs:annotation>

							<xs:complexType>
								<xs:all>
									<xs:element name="players">
										<xs:complexType>
											<xs:sequence>
												<xs:element name="player" maxOccurs="unbounded">
													<xs:annotation>
														<xs:documentation xml:lang="DE">
															Informationen zu einem Spieler, die nur die Paarungen
															betreffen, und somit nicht in /tournament/players/player
															gehören.
														</xs:documentation>
													</xs:annotation>

													<xs:complexType>
														<xs:all>
															<xs:element name="fixed-board" type="xs:positiveInteger" minOccurs="0">
																<xs:annotation>
																	<xs:documentation xml:lang="DE">
																		Feste Brettnummer.
																	</xs:documentation>
																</xs:annotation>
															</xs:element>

															<xs:element name="not-paired" minOccurs="0">
																<xs:annotation>
																	<xs:documentation xml:lang="DE">
																		Angabe der Runden, in denen ein Spieler aussetzt.
																	</xs:documentation>
																</xs:annotation>

																<xs:complexType>
																	<xs:sequence>
																		<xs:element name="round" type="xs:positiveInteger" maxOccurs="unbounded" />
																	</xs:sequence>


																	<xs:assert test="every $i in 1 to count(round)-1 satisfies (xs:integer(round[$i]) lt xs:integer(round[$i+1]))" xerces:message="Rounds must be listed in ascending order.">
																		<xs:annotation>
																			<xs:documentation xml:lang="DE">
																				Angegebene Runden sind aufsteigend sortiert.
																			</xs:documentation>
																		</xs:annotation>
																	</xs:assert>
																</xs:complexType>
															</xs:element>
														</xs:all>

														<xs:attribute name="id" type="xs:positiveInteger" use="required" />
													</xs:complexType>
												</xs:element>
											</xs:sequence>


											<xs:assert test="every $i in 1 to count(player)-1 satisfies (xs:integer(player[$i]/@id) lt xs:integer(player[$i+1]/@id))" xerces:message="Players must be listed in ascending order of their IDs.">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Angegebene Spieler sind aufsteigend nach ihrer ID sortiert.
													</xs:documentation>
												</xs:annotation>
											</xs:assert>
										</xs:complexType>

										<xs:unique name="_s_constraints-teams_unique-fixed-board">
											<xs:annotation>
												<xs:documentation xml:lang="DE">
													Jede feste Brettnummer kann nur genau einmal vergeben werden.
												</xs:documentation>
											</xs:annotation>

											<xs:selector xpath="player" />
											<xs:field xpath="fixed-board" />
										</xs:unique>
									</xs:element>
								</xs:all>
							</xs:complexType>
						</xs:element>
					</xs:all>
				</xs:complexType>
			</xs:element> -->

<!-- 			<xs:element name="rankings" minOccurs="0">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="initial" minOccurs="0">
							<xs:complexType>
								<xs:all>
									<xs:element name="criteria">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Kriterien zur Bildung der Startliste.
											</xs:documentation>
										</xs:annotation>

										<xs:complexType>
											<xs:sequence>
												<xs:element name="criterion" type="ranking-criterion" maxOccurs="unbounded">
													<xs:alternative test="@type eq 'Rating'" type="initial-ranking-criterion-Rating" />
													<xs:alternative test="@type eq 'Custom'" type="initial-ranking-criterion-Custom" />

													<xs:alternative test="true()" type="initial-ranking-criterion" />
												</xs:element>
											</xs:sequence>


											<xs:assert test="every $i in 1 to count(criterion) satisfies (criterion[$i]/@number eq $i)" xerces:message="Criteria must be serially numbered, beginning with 1">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Die Kriterien müssen über ihr @number Attribut aufsteigend
														nummeriert sein, beginnend bei 1.
													</xs:documentation>
												</xs:annotation>
											</xs:assert>

											<xs:assert test="empty(criterion[@type eq 'Random']) or criterion[@type eq 'Random']/@number eq criterion[position() eq last()]/@number" xerces:message="Criterion 'Random' could only be the last one.">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														"Random" kann nur das letzte Kriterium sein.
													</xs:documentation>
												</xs:annotation>
											</xs:assert>
										</xs:complexType>


										<xs:unique name="_s_initial-ranking-criteria_unique-custom-names">
											<xs:annotation>
												<xs:documentation xml:lang="DE">
													Der in criterion/name genannte Name von selbst definierten
													Feinwertungen ist eindeutig.
												</xs:documentation>
											</xs:annotation>

											<xs:selector xpath="criterion" />
											<xs:field xpath="name" />
										</xs:unique>
										<xs:unique name="_s_initial-ranking-criteria_unique-custom-abbreviation">
											<xs:annotation>
												<xs:documentation xml:lang="DE">
													Die in criterion/name/@abbreviation genannte Abkürzung von 
													selbst definierten Feinwertungen ist eindeutig.
												</xs:documentation>
											</xs:annotation>

											<xs:selector xpath="criterion" />
											<xs:field xpath="name/@abbreviation" />
										</xs:unique>
									</xs:element>
								</xs:all>
							</xs:complexType>
						</xs:element>

						<xs:element name="rounds" minOccurs="0">
							<xs:complexType>
								<xs:all>
									<xs:element name="criteria" type="individual-rounds-ranking-criteria">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Wertungen zur Bildung der Rangliste.
											</xs:documentation>
										</xs:annotation>


										<xs:unique name="_s_rounds-ranking-criteria_unique-custom-names">
											<xs:annotation>
												<xs:documentation xml:lang="DE">
													Der in criterion/name genannte Name von selbst definierten
													Feinwertungen ist eindeutig.
												</xs:documentation>
											</xs:annotation>

											<xs:selector xpath="criterion" />
											<xs:field xpath="name" />
										</xs:unique>

										<xs:unique name="_s_rounds-ranking-criteria_unique-custom-abbreviation">
											<xs:annotation>
												<xs:documentation xml:lang="DE">
													Die in criterion/name/@abbreviation genannte Abkürzung von 
													selbst definierten Feinwertungen ist eindeutig.
												</xs:documentation>
											</xs:annotation>

											<xs:selector xpath="criterion" />
											<xs:field xpath="name/@abbreviation" />
										</xs:unique>
									</xs:element>
								</xs:all>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element> -->
		</xs:all>


		<xs:assert 
			test="if (count(pairings/system/colors/max-difference) gt 0) then (xs:integer(pairings/system/colors/max-difference) le xs:integer(general/rounds)) else (true())" 
			xerces:message="The maximal color difference, specified in /tournament/settings/pairings/system/colors/max-difference, must be less or equal to the number of rounds, /tournament/settings/general/rounds." />

		<xs:assert 
			test="if (count(pairings/system/colors/max-series) gt 0) then (xs:integer(pairings/system/colors/max-series) le xs:integer(general/rounds)) else (true())" 
			xerces:message="The maximal color series, specified in /tournament/settings/pairings/system/colors/max-series, must be less or equal to the number of rounds, /tournament/settings/general/rounds." />

		<xs:assert 
			test="every $round in pairings/system/pairing-constraints/constraint/rounds/round satisfies (xs:integer($round) le xs:integer(general/rounds))" 
			xerces:message="Every round number listed in /tournament/settings/pairings/system/pairing-constraints/constraint/rounds/round must be less or equal to the number of rounds, /tournament/settings/general/rounds." />
	</xs:complexType>

	<xs:complexType name="rankings">
<!-- 		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Turnierranglisten, insbesondere auch die Startrangliste, welche
				mindestens hinterlegt sein muss.
			</xs:documentation>
		</xs:annotation>

		<xs:sequence>
			<xs:element name="initial">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Startrangliste.
					</xs:documentation>
				</xs:annotation>

				<xs:complexType>
					<xs:sequence>
						<xs:element name="player" minOccurs="0" maxOccurs="unbounded">
							<xs:complexType>
								<xs:attribute name="position" type="xs:positiveInteger" use="required" />

								<xs:attribute name="id" type="xs:positiveInteger" use="required" />
							</xs:complexType>
						</xs:element>
					</xs:sequence>

					<xs:assert test="every $i in 1 to count(player) satisfies (player[$i]/@position eq $i)" xerces:message="The positions in player/@position in rankings must be serially numbered, beginning with 1.">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Die Positionen in player/@position sind aufsteigend
								durchnummeriert, beginnend bei 1.
							</xs:documentation>
						</xs:annotation>
					</xs:assert>
				</xs:complexType>

				<xs:unique name="unique-rankings-initial-player-position">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Die angegebenen Positionen müssen in der Startrangliste 
							(im Gegensatz zu herkömmlichen Ranglisten) eindeutig sein.
						</xs:documentation>
					</xs:annotation>

					<xs:selector xpath="player" />
					<xs:field xpath="@position" />
				</xs:unique>

				<xs:unique name="unique-rankings-initial-player-id">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Die angegebenen Spieler dürfen nur einmal in der Startrangliste
							geführt werden.
						</xs:documentation>
					</xs:annotation>

					<xs:selector xpath="player" />
					<xs:field xpath="@id" />
				</xs:unique>
			</xs:element>

			<xs:choice minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Für jede Runde kann eine Rangliste gespeichert werden.
						Handelt es sich um ein Rundenturnier mit mehr als einem
						Durchgang, d.h.
						/tournament/settings/pairings/system[@type eq 'Round-Robin']/innings > 1,
						sind die 'inning' die Kindelemente, ansonsten 'round'.
					</xs:documentation>
				</xs:annotation>

				<xs:element name="rounds">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Tür Turniere mit nur einem Durchgang.
							Für jede Runde kann eine Rangliste gespeichert werden.
						</xs:documentation>
					</xs:annotation>

					<xs:complexType>
						<xs:sequence>
							<xs:element name="round" type="_s_ranking-round" maxOccurs="unbounded" />
						</xs:sequence>
					</xs:complexType>
				</xs:element>

				<xs:element name="innings">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Tür Turniere mit mehreren Durchgängen.
						</xs:documentation>
					</xs:annotation>

					<xs:complexType>
						<xs:sequence>
							<xs:element name="inning" maxOccurs="unbounded">
								<xs:complexType>
									<xs:sequence>
										<xs:element name="rounds">
											<xs:complexType>
												<xs:sequence>
													<xs:element name="round" type="_s_ranking-round" maxOccurs="unbounded" />
												</xs:sequence>
											</xs:complexType>
										</xs:element>
									</xs:sequence>

									<xs:attribute name="number" type="xs:positiveInteger" use="required" />
								</xs:complexType>
							</xs:element>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:choice>
		</xs:sequence> -->
	</xs:complexType>

	<xs:complexType name="pairings">
		<xs:choice>
			<xs:annotation>
				<xs:documentation xml:lang="EN">
					In general, the 'pairings'-Node contains the 'round'-nodes.
					But if it's a round-robin tournament 
					(i.e. /tournament/settings/pairings/system/@type = 'Round-Robin')
					and there are more than one inning played
					(i.e. /tournament/settings/pairings/system[@type eq 'Round-Robin']/innings gt 1)
					at this level there are first the 'inning'-nodes.
				</xs:documentation>
			</xs:annotation>

			<xs:sequence>
				<xs:element name="round" type="round" maxOccurs="unbounded">
					<xs:unique name="_s_round-unique-player">
						<xs:annotation>
							<xs:documentation xml:lang="EN">
								Each player is allowed to be paired only once per round.
							</xs:documentation>
						</xs:annotation>

						<xs:selector xpath="boards/board/player | boards/board/white | boards/board/black" />
						<xs:field xpath="@id | @player" />
					</xs:unique>
				</xs:element>
			</xs:sequence>

			<xs:sequence>
				<xs:element name="inning" maxOccurs="unbounded">
					<xs:annotation>
						<xs:documentation xml:lang="EN">
							Inning. Contains at least an 'information' or 'boards' node.
						</xs:documentation>
					</xs:annotation>

					<xs:complexType>
						<xs:sequence>
							<xs:element name="information" type="tournament:pairing-information_single" minOccurs="0" />

							<xs:element name="notes" type="tournament:notes" minOccurs="0" />

							<xs:element name="rounds" minOccurs="0">
								<xs:complexType>
									<xs:sequence>
										<xs:element name="round" type="round" maxOccurs="unbounded">
											<xs:unique name="_s_with-innings_round-unique-player">
												<xs:annotation>
													<xs:documentation xml:lang="EN">
														Each player is allowed to be paired only once per round.
													</xs:documentation>
												</xs:annotation>

												<xs:selector xpath="boards/board/player | boards/board/white | boards/board/black" />
												<xs:field xpath="@id | @player" />
											</xs:unique>
										</xs:element>
									</xs:sequence>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
				
						<xs:attribute name="number" type="xs:positiveInteger" use="required" />
					</xs:complexType>
				</xs:element>
			</xs:sequence>
		</xs:choice>


		<xs:assert 
			test="every $i in 1 to count(round) satisfies (round[$i]/@number = $i)" 
			xerces:message="Round numbers must be serially numbered, beginning with 1." />

		<xs:assert 
			test="every $i in 1 to count(inning) satisfies (inning[$i]/@number = $i)" 
			xerces:message="Inning numbers must be serially numbered, beginning with 1." />
	</xs:complexType>

	<xs:complexType name="round">
		<xs:annotation>
			<xs:documentation xml:lang="EN">
				Single round in a Team Tournament.
				Contains at least an 'information' or 'boards' node.
			</xs:documentation>
		</xs:annotation>

		<xs:sequence>
			<xs:element name="information" type="tournament:pairing-information" minOccurs="0" />

			<xs:element name="notes" type="tournament:notes" minOccurs="0" />

			<xs:element name="boards" minOccurs="0">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="board" type="tournament:board_abstract" maxOccurs="unbounded">
							<xs:alternative test="@attribute eq 'bye'" type="tournament:board_bye" />
							<xs:alternative test="true()" type="board" />
						</xs:element>
					</xs:sequence>


					<xs:assert 
						test="every $i in 1 to count(board) satisfies (board[$i]/@number = $i)" 
						xerces:message="Board numbers must be serially numbered, beginning with 1." />

					<xs:assert 
						test="every $i in (board/white/@player | board/black/@player) satisfies 
										(count((board/white | board/black)[@player = $i]) eq 1)" 
						xerces:message="Every player can be paired only once per round." />
				</xs:complexType>
			</xs:element>
		</xs:sequence>

		<xs:attribute name="number" type="xs:positiveInteger" use="required" />
	</xs:complexType>

	<xs:complexType name="board">
		<xs:complexContent>
			<xs:extension base="tournament:board_abstract">
				<xs:choice>
					<xs:sequence>
						<xs:annotation>
							<xs:documentation xml:lang="EN">
								Single game information by providing both players and their
								results.
								This format is used for every Tournament, where only a single
								game is played per round.
							</xs:documentation>
						</xs:annotation>

						<xs:element name="white" type="tournament:board-single-player" />

						<xs:element name="black" type="tournament:board-single-player" />

						<xs:element name="result" type="tournament:result-single" minOccurs="0" maxOccurs="2">
							<xs:annotation>
								<xs:documentation xml:lang="EN">
									The game result can be saved upto two times:
										* no 'result' node:
											There is no result known, probably not yet played.
										* single 'result' node:
											Game played and result set.
										* two 'result' nodes:
											Original played result has been overruled by a tournament
											instance like the arbiter. Exactly one 'result' element
											has the @attribute='overruled' set.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>

					<xs:sequence>
						<xs:annotation>
							<xs:documentation xml:lang="EN">
								Specification of opponents and their results for Tournaments
								where more than one game is played per round.
								There's no way to set a @swapped='true' attribute for the whole
								pairing, instead every single game has to be marked as @swapped.
							</xs:documentation>
						</xs:annotation>

						<xs:element name="player" minOccurs="2" maxOccurs="2">
							<xs:complexType>
								<xs:attribute name="position" use="required">
									<xs:annotation>
										<xs:documentation xml:lang="EN">
											Specification of being named first or second.
										</xs:documentation>
									</xs:annotation>

									<xs:simpleType>
										<xs:restriction base="xs:positiveInteger">
											<xs:enumeration value="1" />
											<xs:enumeration value="2" />
										</xs:restriction>
									</xs:simpleType>
								</xs:attribute>

								<xs:attribute name="id" type="xs:positiveInteger" use="required" />
							</xs:complexType>
						</xs:element>

						<xs:choice>
							<xs:element name="games">
								<xs:annotation>
									<xs:documentation xml:lang="EN">
										List of all single games.
									</xs:documentation>
								</xs:annotation>

								<xs:complexType>
									<xs:sequence>
										<xs:element name="game" minOccurs="2" maxOccurs="unbounded">
											<xs:complexType>
												<xs:sequence>
													<xs:element name="white" type="tournament:board-single-player" />

													<xs:element name="black" type="tournament:board-single-player" />

													<xs:element name="result" type="tournament:result-single" minOccurs="0" maxOccurs="2" />
												</xs:sequence>

												<xs:attribute name="number" type="xs:positiveInteger" use="required" />

												<xs:attribute name="swapped" type="xs:boolean" use="optional" default="false">
													<xs:annotation>
														<xs:documentation xml:lang="EN">
															Flag whether the game has been played with swapped colors. The original
															pairing is always saved, so the @swapped='true' attribute is the only
															way to mark changed colors.
														</xs:documentation>
													</xs:annotation>
												</xs:attribute>
											</xs:complexType>

											<xs:unique name="multiple-games_game_unique-opponent">
												<xs:annotation>
													<xs:documentation xml:lang="EN">
														The white and black player must have different player-ID's
														in their @player attribute.
													</xs:documentation>
												</xs:annotation>

												<xs:selector xpath="white | black" />
												<xs:field xpath="@player" />
											</xs:unique>
										</xs:element>
									</xs:sequence>

									<xs:assert 
										test="every $i in 1 to count(game) satisfies (game[$i]/@number eq $i)" 
										xerces:message="The games must be serially numbered by their @number attribute, beginning with 1." />
								</xs:complexType>
							</xs:element>

							<xs:element name="results">
								<xs:annotation>
									<xs:documentation xml:lang="EN">
										List of the results of all (yet finished) single games.
									</xs:documentation>
								</xs:annotation>

								<xs:complexType>
									<xs:sequence>
										<xs:element name="player" minOccurs="2" maxOccurs="2">
											<xs:complexType>
												<xs:sequence>
													<xs:element name="wins" type="tournament:single-result-summarization" minOccurs="0" maxOccurs="unbounded" />
													<xs:element name="draws" type="tournament:single-result-summarization" minOccurs="0" maxOccurs="unbounded" />
													<xs:element name="losses" type="tournament:single-result-summarization" minOccurs="0" maxOccurs="unbounded" />
												</xs:sequence>

												<xs:attribute name="position" use="required">
													<xs:simpleType>
														<xs:restriction base="xs:positiveInteger">
															<xs:enumeration value="1" />
															<xs:enumeration value="2" />
														</xs:restriction>
													</xs:simpleType>
												</xs:attribute>
											</xs:complexType>


											<xs:unique name="_s_unique-result-entry_wins">
												<xs:selector xpath="wins" />
												<xs:field xpath="@attribute" />
											</xs:unique>
											<xs:unique name="_s_unique-result-entry_draws">
												<xs:selector xpath="draws" />
												<xs:field xpath="@attribute" />
											</xs:unique>
											<xs:unique name="_s_unique-result-entry_losses">
												<xs:selector xpath="losses" />
												<xs:field xpath="@attribute" />
											</xs:unique>
										</xs:element>
									</xs:sequence>


									<xs:attribute name="overruled" type="xs:boolean" use="optional" default="false">
										<xs:annotation>
											<xs:documentation xml:lang="EN">
												Result which has been overruled by a tournament instance like
												the arbiter. In this case the originally played result has been
												marked with this @overruled attribute.
											</xs:documentation>
										</xs:annotation>
									</xs:attribute>


									<xs:assert 
										test="every $i in 1 to count(player) satisfies (player[$i]/@position and player[$i]/@position eq $i)" 
										xerces:message="The players @position must be serially numbered, beginning with 1." />
									<xs:assert 
										test="sum(player[1]/*) eq sum(player[2]/*)" 
										xerces:message="The number of saved results of both players must be equal." />
								</xs:complexType>
							</xs:element>
						</xs:choice>
					</xs:sequence>
				</xs:choice>

				<xs:attribute name="swapped" type="xs:boolean" use="optional" default="false">
					<xs:annotation>
						<xs:documentation xml:lang="EN">
							Flag whether the game has been played with swapped colors.
							The original pairing is always saved, so the @swapped='true'
							attribute is the only way to mark those results.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>


				<xs:assert 
					test="if (count(result) ge 1) then (count(result[not(xs:boolean(@overruled))]) eq 1) else true()" 
					xerces:message="If multiple results are given, only one should have the @overruled='false' set." />

				<xs:assert 
					test="every $i in 1 to count(player) satisfies (player[$i]/@position and player[$i]/@position eq $i)" 
					xerces:message="The player/@position must be serially numbered, beginning with 1." />

				<xs:assert 
					test="xs:string(@swapped) eq 'false' or count(games) eq 0" 
					xerces:message="The @swapped attribute of boards must not be set to 'true' in tournaments with multiple games per round. Please mark instead every single game as @swapped." />

				<xs:assert 
					test="every $id in (games/game/(white | black)/@player) satisfies ($id eq player[1]/@id or $id eq player[2]/@id)" 
					xerces:message="The players referenced in each game must be the same as for this board." />

				<xs:assert 
					test="if (count(results) ge 1) then (count(results[not(xs:boolean(@overruled))]) eq 1) else true()" 
					xerces:message="There must be exactly one result with @overrule='false'." />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
</xs:schema>