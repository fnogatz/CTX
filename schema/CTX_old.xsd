<?xml version="1.0" encoding="UTF-8" ?>

<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xerces="http://xerces.apache.org">

	<xs:annotation>
		<xs:documentation xml:lang="DE">
			CTX Turnierdatei für Einzel- und Mannschaftsturniere.
		</xs:documentation>
		<xs:documentation xml:lang="EN">
			CTX Tournament file for individual as well as team tournaments.
		</xs:documentation>
	</xs:annotation>

	<xs:include schemaLocation="ISO3166-Country-Code/ISO3166-Country-Code.xsd" />
	<xs:include schemaLocation="IOC-Country-Code.xsd" />


	<xs:element name="tournament" type="tournament">
		<xs:annotation>
			<xs:documentation xml:lang="EN">
				Root-Element: tournament.
			</xs:documentation>
		</xs:annotation>

		<xs:alternative test="@type = 'team'" type="tournament-team" />
		<xs:alternative test="@type = 'individual'" type="tournament-single" />


		<xs:key name="player-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Index über die Spieler-IDs in /tournament/players/player/@id
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="players/player" />
			<xs:field xpath="@id" />
		</xs:key>

		<xs:keyref name="player-id-keyref" refer="player-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Keyref: Die in /tournament/teams/team/players/player genannte @id muss 
					ein player-id-key sein. Erübrigt sich bei Einzelturnieren.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="teams/team/players/player" />
			<xs:field xpath="@id" />
		</xs:keyref>

		<xs:keyref name="_s_player-pairing-keyref" refer="player-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Keyref: Die in
					/tournament/pairings/round/boards/board/{white,black},
					/tournament/pairings/round/boards/board/player,
					/tournament/pairings/round/boards/board/games/game/{white,black}
					genannte @player ID muss ein player-id-key sein. Erübrigt sich bei Mannschaftsturnieren.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="pairings/round/boards/board/white
												| pairings/round/boards/board/black
												|	pairings/round/boards/board/player
												| pairings/round/boards/board/games/game/white
												| pairings/round/boards/board/games/game/black
												| pairings/inning/rounds/round/boards/board/white
												| pairings/inning/rounds/round/boards/board/black
												| pairings/inning/rounds/round/boards/board/player
												| pairings/inning/rounds/round/boards/board/games/game/white
												| pairings/inning/rounds/round/boards/board/games/game/black
												" />
			<xs:field xpath="@player | @id" />
		</xs:keyref>

		<xs:keyref name="_s_player-rankings-initial-keyref" refer="player-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Keyref: Die in /tournament/rankings/initial/player genannte @id muss ein 
					player-id-key sein. Erübrigt sich bei Mannschaftsturnieren.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="rankings/initial/player" />
			<xs:field xpath="@id" />
		</xs:keyref>

		<xs:keyref name="_t_player-pairing-keyref" refer="player-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Keyref: Die in /tournament/pairings/round/tables/table/boards/board/{white,black}
					genannte @player ID muss ein player-id-key sein. Erübrigt sich bei Einzelturnieren.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="pairings/round/tables/table/boards/board/white
												| pairings/round/tables/table/boards/board/black
												| pairings/round/tables/table/boards/board/player
												| pairings/round/tables/table/boards/board/games/game/white
												| pairings/round/tables/table/boards/board/games/game/black
												| pairings/inning/rounds/round/tables/table/boards/board/white
												| pairings/inning/rounds/round/tables/table/boards/board/black
												| pairings/inning/rounds/round/tables/table/boards/board/player
												| pairings/inning/rounds/round/tables/table/boards/board/games/game/white
												| pairings/inning/rounds/round/tables/table/boards/board/games/game/black
												" />
			<xs:field xpath="@player | @id" />
		</xs:keyref>

		<xs:keyref name="_s_settings-pairings-constraints-player-keyref" refer="player-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Keyref: Die in /tournament/settings/pairings/constraints/players/player
					genannte @id muss ein player-id-key sein.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="settings/pairings/constraints/players/player" />
			<xs:field xpath="@id" />
		</xs:keyref>


		<xs:unique name="unique-player-fide-id">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Die /tournament/players/player/identifiers/fide/id muss eindeutig sein.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="players/player/identifiers/fide" />
			<xs:field xpath="id" />
		</xs:unique>

		<xs:unique name="unique-player-federation-id">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Die in /tournament/players/player/identifiers/federation 
					genannte (@code, id) Kombination muss eindeutig sein.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="players/player/identifiers/federation" />
			<xs:field xpath="@code" />
			<xs:field xpath="id" />
		</xs:unique>

		<xs:unique name="unique-player-club-id-member">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Die in /tournament/players/player/identifiers/club
					geführten Tripel (@federation, id, member-id)
					müssen eindeutig sein.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="players/player/identifiers/club" />
			<xs:field xpath="@federation" />
			<xs:field xpath="id" />
			<xs:field xpath="member-id" />
		</xs:unique>

		<xs:unique name="unique-team-federation-team-number">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Die in /tournament/teams/team/identifiers/federation
					geführten Paare (@code, team-number)
					müssen eindeutig sein.
					Die Landesauswahlen müssen also unterschiedlich nummeriert
					sein.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="teams/team/identifiers/federation" />
			<xs:field xpath="@code" />
			<xs:field xpath="team-number" />
		</xs:unique>

		<xs:unique name="unique-team-club-team-number">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Die in /tournament/teams/team/identifiers/club
					geführten Paare (name, team-number)
					müssen eindeutig sein.
					Mehrere Mannschaften eines Vereins müssen also 
					unterschiedlich nummeriert sein.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="teams/team/identifiers/club" />
			<xs:field xpath="name" />
			<xs:field xpath="team-number" />
		</xs:unique>


		<xs:key name="team-id-key">
			<xs:selector xpath="teams/team" />
			<xs:field xpath="@id" />
		</xs:key>

		<xs:keyref name="_t_team-rankings-initial-keyref" refer="team-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					[Mannschaftsturnier]
					Keyref: Die in /tournament/rankings/initial/team genannte @id muss ein 
					team-id-key sein. Erübrigt sich bei Einzelturnieren.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="rankings/initial/team" />
			<xs:field xpath="@id" />
		</xs:keyref>


		<xs:key name="round-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Index über die Rundennummern in /tournament/pairings/round/@number
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="pairings/round" />
			<xs:field xpath="@number" />
		</xs:key>

		<xs:key name="inning-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Index über die Durchgänge in /tournament/pairings/inning/@number
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="pairings/inning" />
			<xs:field xpath="@number" />
		</xs:key>

		
		<xs:key name="team-location-key">
			<xs:selector xpath="teams/team/locations/location" />
			<xs:field xpath="@id" />
		</xs:key>
		
		<xs:keyref name="team-location-keyref" refer="team-location-key">
			<xs:selector xpath="pairings/round/tables/table/information/host
												| pairings/inning/rounds/round/tables/table/information/host
												" />
			<xs:field xpath="@location" />
		</xs:keyref>

		<xs:keyref name="team-location-team-keyref" refer="team-id-key">
			<xs:selector xpath="pairings/round/tables/table/information/host
												| pairings/inning/rounds/round/tables/table/information/host
												" />
			<xs:field xpath="@team" />
		</xs:keyref>

		<xs:keyref name="_t_team-pairing-keyref" refer="team-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Keyref: Die in /tournament/pairings//round/tables/table/team 
					genannte @id muss ein team-id-key sein. Erübrigt sich bei Einzelturnieren.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="pairings/round/tables/table/team
												| pairings/inning/rounds/round/tables/table/team
												" />
			<xs:field xpath="@id" />
		</xs:keyref>

		<xs:keyref name="_t_team-pairing-boards-keyref" refer="team-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Keyref: Die in /tournament/pairings//round/tables/table/boards/board/{white,black,player}/@team
					genannte Team-ID muss ein team-id-key sein. Erübrigt sich bei Einzelturnieren.
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="pairings/round/tables/table/boards/board/white 
												| pairings/round/tables/table/boards/board/black
												| pairings/round/tables/table/boards/board/player
												| pairings/inning/rounds/round/tables/table/boards/board/white
												| pairings/inning/rounds/round/tables/table/boards/board/black
												| pairings/inning/rounds/round/tables/table/boards/board/player
												" />
			<xs:field xpath="@team" />
		</xs:keyref>


		<xs:key name="arbiter-id-key">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Index über die Schiedsrichter-IDs in /tournament/information/arbiters/arbiter/@id
				</xs:documentation>
			</xs:annotation>

			<xs:selector xpath="information/arbiters/arbiter" />
			<xs:field xpath="@id" />
		</xs:key>

		<xs:keyref name="team-pairings-arbiter-keyref" refer="arbiter-id-key">
			<xs:selector xpath="pairings/round/tables/table/information/arbiters/arbiter
												| pairings/inning/rounds/round/tables/table/information/arbiters/arbiter
												" />
			<xs:field xpath="@id" />
		</xs:keyref>
	</xs:element>


	<xs:complexType name="tournament">
		<xs:all>
			<xs:element name="information">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Allgemeine, statische Turnierinformationen
					</xs:documentation>
				</xs:annotation>

				<xs:complexType>
					<xs:sequence>
						<xs:element name="name" type="tournament-name">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Turniername
								</xs:documentation>
							</xs:annotation>
						</xs:element>

						<xs:element name="description" type="xs:string" minOccurs="0">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Freier Beschreibungstext.
									Optional.
								</xs:documentation>
							</xs:annotation>
						</xs:element>

						<xs:element name="date">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="start" type="xs:date" />
									<xs:element name="end" type="xs:date" />
								</xs:sequence>

								<xs:assert test="start le end" xerces:message="Start date must be before end date">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Prüfen, ob End-Datum nach Start-Datum liegt oder sie
											gleich sind.
										</xs:documentation>
									</xs:annotation>
								</xs:assert>
							</xs:complexType>
						</xs:element>

						<xs:element name="location" type="location" minOccurs="0" />

						<xs:element name="time-controls" type="xs:anyType" minOccurs="0">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Erlaubt zwei Typen:
										* time-controls-complex: Angabe als komplexer Typ
										* (deprecated) time-controls-string: Angabe als String 
											-- nur wenn type-Attribut gesetzt und gleich "string" ist
								</xs:documentation>
							</xs:annotation>

							<xs:alternative test="if (count(@type) eq 1) then (@type eq 'string') else false()" type="time-controls-string" />
							<xs:alternative test="true()" type="time-controls-complex" />
						</xs:element>

						<xs:element name="arbiters" type="xs:anyType" minOccurs="0">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Alle Schiedsrichter, insbesondere auch bei Ligen.
									Erlaubt zwei Typen:
										* arbiters-complex: Angabe als komplexer Typ
										* (deprecated) arbiters-string: Angabe als String 
											-- nur wenn type-Attribut gesetzt und gleich "string" ist
								</xs:documentation>
							</xs:annotation>

							<xs:alternative test="@type and @type eq 'string'" type="arbiters-string" />
							<xs:alternative test="true()" type="arbiters-complex" />
						</xs:element>

						<xs:element name="rating-versions" minOccurs="0">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="rating" maxOccurs="unbounded">
										<xs:complexType>
											<xs:simpleContent>
												<xs:extension base="xs:date">
													<xs:attribute name="type" type="rating-system" use="optional" default="" />
												</xs:extension>
											</xs:simpleContent>
										</xs:complexType>
									</xs:element>
								</xs:sequence>
							</xs:complexType>

							<xs:unique name="unique-rating-version">
								<xs:selector xpath="rating" />
								<xs:field xpath="@type" />
							</xs:unique>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>

			<xs:element name="players" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Liste aller Spieler.
					</xs:documentation>
				</xs:annotation>

				<xs:complexType>
					<xs:sequence>
						<xs:element name="player" type="player" maxOccurs="unbounded" />
					</xs:sequence>

					<xs:assert test="
						every $i in 1 to count(player)-1 satisfies (
							if (player[$i]/name/@type eq 'string') then (
								if (player[$i+1]/name/@type eq 'string') then (
									compare(
										lower-case(player[$i]/name),
										lower-case(player[$i+1]/name)
									) le 0
								) else (
									compare(
										lower-case(player[$i]/name),
										lower-case(concat(player[$i+1]/name/surname, ',', player[$i+1]/name/prename, ',', player[$i+1]/name/academic-title))
									) le 0
								)
							) else (
								if (player[$i+1]/name/@type eq 'string') then (
									compare(
										lower-case(concat(player[$i]/name/surname, ',', player[$i]/name/prename, ',', player[$i]/name/academic-title)),
										lower-case(player[$i+1]/name)
									) le 0
								) else (
									compare(
										lower-case(concat(player[$i]/name/surname, ',', player[$i]/name/prename, ',', player[$i]/name/academic-title)),
										lower-case(concat(player[$i+1]/name/surname, ',', player[$i+1]/name/prename, ',', player[$i+1]/name/academic-title))
									) le 0
								)
							)
						)
					" xerces:message="Players must be sorted by their name.">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Spieler sind aufsteigend sortiert nach Name, d.h. 
								
								Achtung: Die Sortierung erfolgt abhängig von der Collation,
								d.h. standardmäßig 'a' lt 'z' lt 'ä' lt 'ö' lt 'ü'.
							</xs:documentation>
						</xs:annotation>
					</xs:assert>

					<xs:assert test="every $i in 1 to count(player) satisfies (player[$i]/@id eq $i)" xerces:message="Players must be serially numbered, beginning with 1.">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Spieler (player/@id) sind aufsteigend durchnummeriert, beginnend bei 1.
							</xs:documentation>
						</xs:annotation>
					</xs:assert>
				</xs:complexType>
			</xs:element>
		</xs:all>

		<xs:attribute name="type" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="team" />
					<xs:enumeration value="individual" />
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>


		<xs:assert test="every $p in players/player/birth-year satisfies (xs:int($p) le xs:int(year-from-date(information/date/start)))" xerces:message="Every player's birth year must be before the tournament's starting date.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Bedingung (XSD1.1): Geburtsjahr jedes Spielers
					muss vor Turnierstart liegen.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="every $p in players/player/birth satisfies ($p lt information/date/start)" xerces:message="Every player's birth must be before the tournament's starting date.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Bedingung (XSD1.1): Geburtstag jedes Spielers
					muss vor Turnierstart liegen.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="every $date in pairings//information/date satisfies ($date le information/date/end)" xerces:message="Round date must be before tournament's ending date.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Bedingung (XSD1.1): Liegt Rundendatum (wenn gesetzt) vor/auf Turnierende?
					Es gibt keinen Filter, der prüft, ob die Runden in der richtigen 
					Reihenfolge gespielt werden. D.h. es muss NICHT zwingend 
					pairings/round[$i+n]/information/date >= pairings/round[$i]/information/date
					gelten.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="every $date in pairings//information/date satisfies ($date ge information/date/start)" xerces:message="Round date must be after tournament's starting date.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Bedingung (XSD1.1): Liegt Rundendatum (wenn gesetzt) nach/auf Turnieranfang?
					Es gibt keinen Filter, der prüft, ob die Runden in der richtigen 
					Reihenfolge gespielt werden. D.h. es muss NICHT zwingend 
					pairings/round[$i+n]/information/date >= pairings/round[$i]/information/date
					gelten.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="if (
											(count(settings/pairings/system[@type eq 'Round-Robin']) eq 0) or 
											(count(settings/pairings/system[@type eq 'Round-Robin']/innings) eq 0) or
											(xs:integer(settings/pairings/system[@type eq 'Round-Robin']/innings) eq 1)
										) then (
											count(pairings/inning) eq 0
										) else (
											count(pairings/round) eq 0
										)" xerces:message="If it is a Round-Robin Tournament, i.e. /tournament/settings/system/@type = 'Round-Robin', and more than one inning is played, i.e. /tournament/settings/system/innings > 1, the child-nodes of /tournament/pairings must be 'inning'. Otherwise /tournament/pairings has to include 'round' elements.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Im Regelfall beinhaltet das /tournament/pairings-Element eine
					Auflistung von 'round'-Elementen.
					Nur bei Rundenturnieren (d.h. /tournament/settings/system/@type = 'Round-Robin')
					mit mehr als einem Durchgang (d.h.
					/tournament/settings/system[@type eq 'Round-Robin']/innings > 1)
					beinhaltet das /tournament/pairings-Element eine Auflistung von
					'inning'-Kindelementen.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="if (
											(count(settings/pairings/system[@type eq 'Round-Robin']) eq 0) or 
											(count(settings/pairings/system[@type eq 'Round-Robin']/innings) eq 0) or
											(xs:integer(settings/pairings/system[@type eq 'Round-Robin']/innings) eq 1)
										) then (
											count(rankings/innings) eq 0
										) else (
											count(rankings/rounds) eq 0
										)" xerces:message="If it is a Round-Robin Tournament, i.e. /tournament/settings/system/@type = 'Round-Robin', and more than one inning is played, i.e. /tournament/settings/system/innings > 1, there must not be an /tournament/rankings/innings element instead of /tournament/rankings/rounds. Tournaments with only one inning must not have any 'innings' element within /tournament/rankings.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Im Regelfall beinhaltet das /tournament/rankings-Element eine
					Auflistung von 'round'-Elementen.
					Nur bei Rundenturnieren (d.h. /tournament/settings/system/@type = 'Round-Robin')
					mit mehr als einem Durchgang (d.h.
					/tournament/settings/system[@type eq 'Round-Robin']/innings > 1)
					beinhaltet das /tournament/rankings-Element stattdesseneine 
					Auflistung von 'inning'-Kindelementen.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="if (
											(count(settings/pairings/system[@type eq 'Round-Robin']) eq 0) or 
											(count(settings/pairings/system[@type eq 'Round-Robin']/innings) eq 0) or
											(xs:integer(settings/pairings/system[@type eq 'Round-Robin']/innings) eq 1)
										) then (
											true()
										) else (
											every $inningno in rankings/innings/inning/@number satisfies ($inningno le settings/pairings/system[@type eq 'Round-Robin']/innings)
										)" xerces:message="If it is a Round-Robin Tournament, i.e. /tournament/settings/system/@type = 'Round-Robin', and more than one inning is played, i.e. /tournament/settings/system/innings > 1, the inning/@number in /tournament/rankings/inning must be less or equal to the specified number of innings in /tournament/settings/pairings/system/innings.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Bei Rundenturnieren (d.h. /tournament/settings/system/@type = 'Round-Robin')
					mit mehr als einem Durchgang (d.h.
					/tournament/settings/system[@type eq 'Round-Robin']/innings > 1)
					überschreitet die inning/@number in /tournament/rankings/inning/@number
					nicht die in /tournament/settings/system[@type eq 'Round-Robin']/innings
					angegebene Anzahl an Durchgängen.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="(count(settings/general/games-per-round) eq 0) or (settings/general/games-per-round eq 1) or count(pairings//board/(white | black)) eq 0" xerces:message="If multiple games are played per round, i.e. /tournament/settings/general/games-per-round is set and greater than 1, the competing players of each board must be referenced through the 'player' element and not by 'white' and 'black'.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Werden mehrere Partien pro Runde gespielt, d.h.
					/tournament/settings/general/games-per-round gt 1,
					müssen die Spieler an einem Brett über das 'player'
					Attribut referenziert werden und nicht wie bei
					Einzelspielen über 'white' und 'black'.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="if (
											(count(settings/general/games-per-round) eq 0) or
											(settings/general/games-per-round eq 1)
										) then (
											count(pairings//board/games/game) eq 0
										) else (
											true()
										)" xerces:message="If only one game is played per round, i.e. /tournament/settings/general/games-per-round is either not set or equal to 1, no 'games' element is allowed within a 'board' element in /tournament/pairings/(...).">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Im Regelfall beinhaltet das /tournament/pairings-Element nur
					'board'-Elemente, die kein 'games'-Unterelement beinhalten.
					Nur bei Turnieren mit mehr als einer Partie pro Runde, d.h.
					/tournament/settings/general/games-per-round gt 1,
					ist dieses 'games'-Kindelement erlaubt.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="if (
											(count(settings/general/games-per-round) eq 0) or
											(settings/general/games-per-round eq 1)
										) then (
											true()
										) else (
											every $games in pairings//board/games satisfies (
												count($games/game) eq xs:integer(settings/general/games-per-round)
											)
										)" xerces:message="If multiple games are played per round, i.e. /tournament/settings/general/games-per-round > 1, the number of 'game' elements in /tournament/pairings/(...)/board/games must be equal to this one specified in /tournament/settings/general/games-per-round.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Im Regelfall beinhaltet das /tournament/pairings-Element nur
					'board'-Elemente, die kein 'games'-Unterelement beinhalten.
					Nur bei Turnieren mit mehr als einer Partie pro Runde, d.h.
					/tournament/settings/general/games-per-round gt 1,
					ist dieses 'games'-Kindelement erlaubt.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="if (
											(count(settings/general/games-per-round) eq 0) or
											(settings/general/games-per-round eq 1)
										) then (
											true()
										) else (
											every $results in pairings//board/results/player satisfies (
												sum($results/*) le settings/general/games-per-round
											)
										)" xerces:message="If more than one game is played per round, i.e. /tournament/settings/general/games-per-round > 1, the number of results in /tournament/pairings/(...)/board/results/player must be less or equal to the number of games specified in /tournament/settings/general/games-per-round.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Werden mehrere Partien pro Runde gespielt, d.h. 
					/tournament/settings/general/games-per-round > 1, darf die Summe
					der Resultate in /tournament/pairings/(...)/board/results/player
					die Anzahl der Partien pro Runde nicht überschreiten.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="every $roundno in pairings//round/@number satisfies ($roundno le settings/general/rounds)" xerces:message="Every round number in /tournament/pairings//round/@number must be less or equal to the specified one in /tournament/settings/general/rounds.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Es dürfen nur Runden mit einer Rundennummer kleiner oder gleich
					der in /tournament/settings/general/rounds genannten Anzahl an
					Runden existieren.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="every $roundno in rankings//rounds/round/@number satisfies ($roundno le settings/general/rounds)" xerces:message="Every round number in /tournament/rankings//round/@number must be less or equal to the specified one in /tournament/settings/general/rounds.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Es dürfen nur Runden mit einer Rundennummer kleiner oder gleich
					der in /tournament/settings/general/rounds genannten Anzahl an
					Runden existieren.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="if (count(pairings/inning) gt 0) then (
											every $round in pairings/inning/rounds/round[boards or tables]/@number satisfies (
												count(pairings/inning/rounds/round[@number eq $round][boards or tables]) eq settings/pairings/system[@type eq 'Round-Robin']/innings
											)
										) else (true())" xerces:message="The pairings of an already paired round must be specified in every inning.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Wurde eine Runde in einem Turnier mit mehreren Durchgängen
					bereits ausgelost, d.h. in
					pairings/inning/rounds/round existiert das Kindelement 'boards'
					oder 'tables', so sind die Paarungen der entsprechenden Runde
					auch in den anderen Durchgängen anzugeben.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="(every $roundno in rankings/rounds/round/@number satisfies (
											count(pairings/round[@number eq $roundno][boards or tables]) gt 0
										)) and
											(every $inningno in rankings/innings/inning/@number satisfies (
												every $roundno in rankings/innings/inning[@number eq $inningno]/rounds/round/@number satisfies (
													count(pairings/inning[@number eq $inningno]/rounds/round[@number eq $roundno][boards or tables]) gt 0
												)
											))
										" xerces:message="There must not be any ranking for rounds, which aren't paired yet.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Es dürfen nur Ranglisten für Runden in /tournament/rankings/rounds
					gespeichert sein, die auch bereits ausgelost sind, d.h. 
					/tournament/pairings/round[@number]/boards darf nicht leer sein.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="every 
												$federation in distinct-values(data((players/player | teams/team)/identifiers/club/@federation)), 
												$id in distinct-values(data((players/player | teams/team)/identifiers/club[@federation eq $federation]/id))
											satisfies (
												count(distinct-values(data((players/player | teams/team)/identifiers/club[@federation eq $federation and xs:string(id) eq xs:string($id)]/name))) eq 1
											)" xerces:message="Clubs of the same club/@federation with the identical club/id must also have the same club/name.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Vereine der gleichen Föderation, die die gleiche Club-ID
					besitzen, müssen auch den gleichen Vereinsnamen tragen.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="every $club_name in distinct-values(data((players/player | teams/team)/identifiers/club/name)) satisfies (
											count(distinct-values(data((players/player | teams/team)/identifiers/club[xs:string(name) eq xs:string($club_name)]/@federation))) le 1
										)" xerces:message="Clubs with the same club/name must also have the identical club/@federation if set. Keep in mind that the Club-Name is an distinct key. If you have clubs of different federations with the same name, you have to suffix them.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Der Vereinsname ist ein Schlüssel. Vereine mit dem
					selben Vereinsnamen müssen demnach auch der gleichen
					Föderation (wenn gesetzt) entstammen.
					Besitzen mehrere teilnehmende Vereine aus verschiedenen
					Ländern den selben Namen, so ist über Suffixe o.ä. die
					Schlüsseleigenschaft wieder herzustellen.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="every $club_name in distinct-values(data((players/player | teams/team)/identifiers/club/name)) satisfies (
											count(distinct-values(data((players/player | teams/team)/identifiers/club[xs:string(name) eq xs:string($club_name)]/id))) le 1
										)" xerces:message="Clubs with the same club/name must also have the identical club/id if set. Keep in mind that the Club-Name is an distinct key. If you have clubs with different IDs but the same name, you have to suffix them.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Der Vereinsname ist ein Schlüssel. Vereine mit dem
					selben Vereinsnamen müssen demnach auch die gleiche ID
					(wenn gesetzt) besitzen.
					Haben mehrere teilnehmende Vereine aus verschiedenen
					Ländern den selben Namen, so ist über Suffixe o.ä. die
					Schlüsseleigenschaft wieder herzustellen.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="count((//@federation | //federation/@code)[string-length(xs:string(.)) eq 2]) eq 0 or count((//@federation | //federation/@code)[string-length(xs:string(.)) eq 3]) eq 0" xerces:message="You have to use either IOC or ISO3166 Country Codes in the complete XML file. Please do not mix both types.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Die Country Codes innerhalb des XML-Dokumentes müssen einheitlich
					alle entweder im IOC- oder ISO3166-Format sein.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>
	</xs:complexType>


	<xs:complexType name="tournament-single">
		<xs:complexContent>
			<xs:extension base="tournament">
				<xs:all>
					<xs:element name="pairings" minOccurs="0">
						<xs:complexType>
							<xs:choice>
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Im Allgemeinen beinhaltet das "pairings"-Element die "round"-Elemente.
										Handelt es sich jedoch um ein Rundenturnier (d.h. 
										/tournament/settings/pairings/system/@type = 'Round-Robin') und wird
										mehr als ein Durchgang (d.h. 
										/tournament/settings/pairings/system[@type eq 'Round-Robin']/innings gt 1)
										gespielt, so kommen auf dieser Ebene die "inning"-Elemente.
									</xs:documentation>
								</xs:annotation>

								<xs:sequence>
									<xs:element name="round" type="_s_round" maxOccurs="unbounded">
										<xs:unique name="_s_round-unique-player">
											<xs:annotation>
												<xs:documentation xml:lang="DE">
													Jeder Spieler darf pro Runde nur einmal gepaart sein.
												</xs:documentation>
											</xs:annotation>

											<xs:selector xpath="boards/board/player | boards/board/white | boards/board/black" />
											<xs:field xpath="@id | @player" />
										</xs:unique>
									</xs:element>
								</xs:sequence>

								<xs:sequence>
									<xs:element name="inning" maxOccurs="unbounded">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Durchgang. Beinhaltet mindestens information oder boards, 
												ist aber in keinem Fall leer.
											</xs:documentation>
										</xs:annotation>

										<xs:complexType>
											<xs:sequence>
												<xs:element name="information" type="pairing-information-single" minOccurs="0" />

												<xs:element name="notes" type="notes" minOccurs="0" />

												<xs:element name="rounds" minOccurs="0">
													<xs:complexType>
														<xs:sequence>
															<xs:element name="round" type="_s_round" maxOccurs="unbounded">
																<xs:unique name="_s_with-innings_round-unique-player">
																	<xs:annotation>
																		<xs:documentation xml:lang="DE">
																			Jeder Spieler darf pro Runde nur einmal gepaart sein.
																		</xs:documentation>
																	</xs:annotation>

																	<xs:selector xpath="boards/board/player | boards/board/white | boards/board/black" />
																	<xs:field xpath="@id | @player" />
																</xs:unique>
															</xs:element>
														</xs:sequence>
													</xs:complexType>
												</xs:element>
											</xs:sequence>
									
											<xs:attribute name="number" type="xs:positiveInteger" use="required" />
										</xs:complexType>
									</xs:element>
								</xs:sequence>
							</xs:choice>


							<xs:assert test="every $i in 1 to count(round) satisfies (round[$i]/@number = $i)" xerces:message="Round numbers must be serially numbered, beginning with 1.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Rundennummern müssen aufsteigend durchnummeriert sein, beginnend bei 1.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>

							<xs:assert test="every $i in 1 to count(inning) satisfies (inning[$i]/@number = $i)" xerces:message="Inning numbers must be serially numbered, beginning with 1.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Durchgänge müssen aufsteigend durchnummeriert sein, beginnend bei 1.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>
						</xs:complexType>
					</xs:element>

					<xs:element name="settings">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Generelle, statische Turniereinstellungen.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:all>
								<xs:element name="general">
									<xs:complexType>
										<xs:all>
											<xs:element name="rounds" type="xs:positiveInteger">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Anzahl der Runden.
														Pflichtangabe.
													</xs:documentation>
												</xs:annotation>
											</xs:element>

											<xs:element name="games-per-round" type="xs:positiveInteger" minOccurs="0">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Partien pro Runde.
														Optional. Implizit 1.
													</xs:documentation>
												</xs:annotation>
											</xs:element>
										</xs:all>
									</xs:complexType>
								</xs:element>

								<xs:element name="points-system" type="game-points-individual" minOccurs="0">
									<xs:unique name="s_unique-game-points-individuals_win">
										<xs:selector xpath="win" />
										<xs:field xpath="@attribute" />
										<xs:field xpath="@color" />
									</xs:unique>
									<xs:unique name="s_unique-game-points-individuals_draw">
										<xs:selector xpath="draw" />
										<xs:field xpath="@attribute" />
										<xs:field xpath="@color" />
									</xs:unique>
									<xs:unique name="s_unique-game-points-individuals_loss">
										<xs:selector xpath="loss" />
										<xs:field xpath="@attribute" />
										<xs:field xpath="@color" />
									</xs:unique>
								</xs:element>

								<xs:element name="pairings" minOccurs="0">
									<xs:complexType>
										<xs:all>
											<xs:element name="system" type="_s_pairings-system" minOccurs="0">
												<xs:alternative type="_s_pairings-system-Swiss" test="@type eq 'Swiss'" />
												<xs:alternative type="_s_pairings-system-Round-Robin" test="@type eq 'Round-Robin'" />
											</xs:element>

											<xs:element name="constraints" minOccurs="0">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Randbedingungen zur Ermittlung der Paarungen, etwa
														feste Brettnummern oder Angabe der Runden, in denen
														einzelne Spieler aussetzen.
													</xs:documentation>
												</xs:annotation>

												<xs:complexType>
													<xs:all>
														<xs:element name="players">
															<xs:complexType>
																<xs:sequence>
																	<xs:element name="player" maxOccurs="unbounded">
																		<xs:annotation>
																			<xs:documentation xml:lang="DE">
																				Informationen zu einem Spieler, die nur die Paarungen
																				betreffen, und somit nicht in /tournament/players/player
																				gehören.
																			</xs:documentation>
																		</xs:annotation>

																		<xs:complexType>
																			<xs:all>
																				<xs:element name="fixed-board" type="xs:positiveInteger" minOccurs="0">
																					<xs:annotation>
																						<xs:documentation xml:lang="DE">
																							Feste Brettnummer.
																						</xs:documentation>
																					</xs:annotation>
																				</xs:element>

																				<xs:element name="not-paired" minOccurs="0">
																					<xs:annotation>
																						<xs:documentation xml:lang="DE">
																							Angabe der Runden, in denen ein Spieler aussetzt.
																						</xs:documentation>
																					</xs:annotation>

																					<xs:complexType>
																						<xs:sequence>
																							<xs:element name="round" type="xs:positiveInteger" maxOccurs="unbounded" />
																						</xs:sequence>


																						<xs:assert test="every $i in 1 to count(round)-1 satisfies (xs:integer(round[$i]) lt xs:integer(round[$i+1]))" xerces:message="Rounds must be listed in ascending order.">
																							<xs:annotation>
																								<xs:documentation xml:lang="DE">
																									Angegebene Runden sind aufsteigend sortiert.
																								</xs:documentation>
																							</xs:annotation>
																						</xs:assert>
																					</xs:complexType>
																				</xs:element>
																			</xs:all>

																			<xs:attribute name="id" type="xs:positiveInteger" use="required" />
																		</xs:complexType>
																	</xs:element>
																</xs:sequence>


																<xs:assert test="every $i in 1 to count(player)-1 satisfies (xs:integer(player[$i]/@id) lt xs:integer(player[$i+1]/@id))" xerces:message="Players must be listed in ascending order of their IDs.">
																	<xs:annotation>
																		<xs:documentation xml:lang="DE">
																			Angegebene Spieler sind aufsteigend nach ihrer ID sortiert.
																		</xs:documentation>
																	</xs:annotation>
																</xs:assert>
															</xs:complexType>

															<xs:unique name="_s_constraints-teams_unique-fixed-board">
																<xs:annotation>
																	<xs:documentation xml:lang="DE">
																		Jede feste Brettnummer kann nur genau einmal vergeben werden.
																	</xs:documentation>
																</xs:annotation>

																<xs:selector xpath="player" />
																<xs:field xpath="fixed-board" />
															</xs:unique>
														</xs:element>
													</xs:all>
												</xs:complexType>
											</xs:element>
										</xs:all>
									</xs:complexType>
								</xs:element>

								<xs:element name="rankings" minOccurs="0">
									<xs:complexType>
										<xs:sequence>
											<xs:element name="initial" minOccurs="0">
												<xs:complexType>
													<xs:all>
														<xs:element name="criteria">
															<xs:annotation>
																<xs:documentation xml:lang="DE">
																	Kriterien zur Bildung der Startliste.
																</xs:documentation>
															</xs:annotation>

															<xs:complexType>
																<xs:sequence>
																	<xs:element name="criterion" type="ranking-criterion" maxOccurs="unbounded">
																		<xs:alternative test="@type eq 'Rating'" type="initial-ranking-criterion-Rating" />
																		<xs:alternative test="@type eq 'Custom'" type="initial-ranking-criterion-Custom" />

																		<xs:alternative test="true()" type="initial-ranking-criterion" />
																	</xs:element>
																</xs:sequence>


																<xs:assert test="every $i in 1 to count(criterion) satisfies (criterion[$i]/@number eq $i)" xerces:message="Criteria must be serially numbered, beginning with 1">
																	<xs:annotation>
																		<xs:documentation xml:lang="DE">
																			Die Kriterien müssen über ihr @number Attribut aufsteigend
																			nummeriert sein, beginnend bei 1.
																		</xs:documentation>
																	</xs:annotation>
																</xs:assert>

																<xs:assert test="empty(criterion[@type eq 'Random']) or criterion[@type eq 'Random']/@number eq criterion[position() eq last()]/@number" xerces:message="Criterion 'Random' could only be the last one.">
																	<xs:annotation>
																		<xs:documentation xml:lang="DE">
																			"Random" kann nur das letzte Kriterium sein.
																		</xs:documentation>
																	</xs:annotation>
																</xs:assert>
															</xs:complexType>


															<xs:unique name="_s_initial-ranking-criteria_unique-custom-names">
																<xs:annotation>
																	<xs:documentation xml:lang="DE">
																		Der in criterion/name genannte Name von selbst definierten
																		Feinwertungen ist eindeutig.
																	</xs:documentation>
																</xs:annotation>

																<xs:selector xpath="criterion" />
																<xs:field xpath="name" />
															</xs:unique>
															<xs:unique name="_s_initial-ranking-criteria_unique-custom-abbreviation">
																<xs:annotation>
																	<xs:documentation xml:lang="DE">
																		Die in criterion/name/@abbreviation genannte Abkürzung von 
																		selbst definierten Feinwertungen ist eindeutig.
																	</xs:documentation>
																</xs:annotation>

																<xs:selector xpath="criterion" />
																<xs:field xpath="name/@abbreviation" />
															</xs:unique>
														</xs:element>
													</xs:all>
												</xs:complexType>
											</xs:element>

											<xs:element name="rounds" minOccurs="0">
												<xs:complexType>
													<xs:all>
														<xs:element name="criteria" type="individual-rounds-ranking-criteria">
															<xs:annotation>
																<xs:documentation xml:lang="DE">
																	Wertungen zur Bildung der Rangliste.
																</xs:documentation>
															</xs:annotation>


															<xs:unique name="_s_rounds-ranking-criteria_unique-custom-names">
																<xs:annotation>
																	<xs:documentation xml:lang="DE">
																		Der in criterion/name genannte Name von selbst definierten
																		Feinwertungen ist eindeutig.
																	</xs:documentation>
																</xs:annotation>

																<xs:selector xpath="criterion" />
																<xs:field xpath="name" />
															</xs:unique>

															<xs:unique name="_s_rounds-ranking-criteria_unique-custom-abbreviation">
																<xs:annotation>
																	<xs:documentation xml:lang="DE">
																		Die in criterion/name/@abbreviation genannte Abkürzung von 
																		selbst definierten Feinwertungen ist eindeutig.
																	</xs:documentation>
																</xs:annotation>

																<xs:selector xpath="criterion" />
																<xs:field xpath="name/@abbreviation" />
															</xs:unique>
														</xs:element>
													</xs:all>
												</xs:complexType>
											</xs:element>
										</xs:sequence>
									</xs:complexType>
								</xs:element>
							</xs:all>


							<xs:assert test="if (count(pairings/system/colors/max-difference) gt 0) then (xs:integer(pairings/system/colors/max-difference) le xs:integer(general/rounds)) else (true())" xerces:message="The maximal color difference, specified in /tournament/settings/pairings/system/colors/max-difference, must be less or equal to the number of rounds, /tournament/settings/general/rounds.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Die maximale Farbdifferenz in
										/tournament/settings/pairings/system/colors/max-difference
										darf die Anzahl der Runden nicht überschreiten.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>

							<xs:assert test="if (count(pairings/system/colors/max-series) gt 0) then (xs:integer(pairings/system/colors/max-series) le xs:integer(general/rounds)) else (true())" xerces:message="The maximal color series, specified in /tournament/settings/pairings/system/colors/max-series, must be less or equal to the number of rounds, /tournament/settings/general/rounds.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Die maximale Farbgleichheit in
										/tournament/settings/pairings/system/colors/max-series
										darf die Anzahl der Runden nicht überschreiten.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>

							<xs:assert test="every $round in pairings/system/pairing-constraints/constraint/rounds/round satisfies (xs:integer($round) le xs:integer(general/rounds))" xerces:message="Every round number listed in /tournament/settings/pairings/system/pairing-constraints/constraint/rounds/round must be less or equal to the number of rounds, /tournament/settings/general/rounds.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Die Runden in
										/tournament/settings/pairings/system/pairing-constraints/constraint/rounds/round
										dürfen die Anzahl der Runden nicht überschreiten.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>
						</xs:complexType>
					</xs:element>

					<xs:element name="rankings" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Turnierranglisten, insbesondere auch die Startrangliste, welche
								mindestens hinterlegt sein muss.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:sequence>
								<xs:element name="initial">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Startrangliste.
										</xs:documentation>
									</xs:annotation>

									<xs:complexType>
										<xs:sequence>
											<xs:element name="player" minOccurs="0" maxOccurs="unbounded">
												<xs:complexType>
													<xs:attribute name="position" type="xs:positiveInteger" use="required" />

													<xs:attribute name="id" type="xs:positiveInteger" use="required" />
												</xs:complexType>
											</xs:element>
										</xs:sequence>

										<xs:assert test="every $i in 1 to count(player) satisfies (player[$i]/@position eq $i)" xerces:message="The positions in player/@position in rankings must be serially numbered, beginning with 1.">
											<xs:annotation>
												<xs:documentation xml:lang="DE">
													Die Positionen in player/@position sind aufsteigend
													durchnummeriert, beginnend bei 1.
												</xs:documentation>
											</xs:annotation>
										</xs:assert>
									</xs:complexType>

									<xs:unique name="unique-rankings-initial-player-position">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Die angegebenen Positionen müssen in der Startrangliste 
												(im Gegensatz zu herkömmlichen Ranglisten) eindeutig sein.
											</xs:documentation>
										</xs:annotation>

										<xs:selector xpath="player" />
										<xs:field xpath="@position" />
									</xs:unique>

									<xs:unique name="unique-rankings-initial-player-id">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Die angegebenen Spieler dürfen nur einmal in der Startrangliste
												geführt werden.
											</xs:documentation>
										</xs:annotation>

										<xs:selector xpath="player" />
										<xs:field xpath="@id" />
									</xs:unique>
								</xs:element>

								<xs:choice minOccurs="0">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Für jede Runde kann eine Rangliste gespeichert werden.
											Handelt es sich um ein Rundenturnier mit mehr als einem
											Durchgang, d.h.
											/tournament/settings/pairings/system[@type eq 'Round-Robin']/innings > 1,
											sind die 'inning' die Kindelemente, ansonsten 'round'.
										</xs:documentation>
									</xs:annotation>

									<xs:element name="rounds">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Tür Turniere mit nur einem Durchgang.
												Für jede Runde kann eine Rangliste gespeichert werden.
											</xs:documentation>
										</xs:annotation>

										<xs:complexType>
											<xs:sequence>
												<xs:element name="round" type="_s_ranking-round" maxOccurs="unbounded" />
											</xs:sequence>
										</xs:complexType>
									</xs:element>

									<xs:element name="innings">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Tür Turniere mit mehreren Durchgängen.
											</xs:documentation>
										</xs:annotation>

										<xs:complexType>
											<xs:sequence>
												<xs:element name="inning" maxOccurs="unbounded">
													<xs:complexType>
														<xs:sequence>
															<xs:element name="rounds">
																<xs:complexType>
																	<xs:sequence>
																		<xs:element name="round" type="_s_ranking-round" maxOccurs="unbounded" />
																	</xs:sequence>
																</xs:complexType>
															</xs:element>
														</xs:sequence>

														<xs:attribute name="number" type="xs:positiveInteger" use="required" />
													</xs:complexType>
												</xs:element>
											</xs:sequence>
										</xs:complexType>
									</xs:element>
								</xs:choice>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:all>

				<xs:assert test="every $id in players/player/@id satisfies ( count(rankings/initial/player[@id eq $id]) eq 1 )" xerces:message="Every player listed in /tournament/players must also be listed in the initial ranking.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Jeder in /tournament/players gelistete Spieler 
							ist auch in der Startrangliste einmal aufgeführt.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="if (count(pairings/inning) gt 0) then (
													every $roundno in pairings/inning[1]/rounds/round[boards]/@number satisfies (
														every $boardno in pairings/inning[1]/rounds/round[@number eq $roundno]/boards/board/@number satisfies (
															every $player in pairings/inning[1]/rounds/round[@number eq $roundno]/boards/board[@number eq $boardno]/(player/@id | white/@player | black/@player) satisfies (
																count(pairings/inning/rounds/round[@number eq $roundno]/boards/board[@number eq $boardno]/player[@id eq $player] | pairings/inning/rounds/round[@number eq $roundno]/boards/board[@number eq $boardno]/(white | black)[@player eq $player]) eq settings/pairings/system[@type eq 'Round-Robin']/innings
															)
														)
													)
												) else (true())" xerces:message="The competiting players on a specific board in a specific round must be the same in all innings.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Wurde eine Runde in einem Turnier mit mehreren Durchgängen
							bereits ausgelost, d.h. in
							pairings/inning/rounds/round existiert das Kindelement 'boards',
							so sind an den Paarungen an einem spezifischen Brett in einer
							bestimmten Runde auch immer die gleichen Spieler beteiligt.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="if (count(pairings/inning) gt 0) then (
													every $inningno in 1 to count(pairings/inning)-1 satisfies (
														every $roundno in pairings/inning[$inningno]/rounds/round[boards]/@number satisfies (
															every $boardno in pairings/inning[$inningno]/rounds/round[@number eq $roundno]/boards/board[not(@attribute) or @attribute ne 'bye']/@number satisfies (
																if (count(pairings/inning[$inningno]/rounds/round[@number eq $roundno]/boards/board[@number eq $boardno]/white) gt 0) then (
																	(: players given by 'white' and 'black' :)
																	pairings/inning[$inningno]/rounds/round[@number eq $roundno]/boards/board[@number eq $boardno]/white/@player eq pairings/inning[$inningno+1]/rounds/round[@number eq $roundno]/boards/board[@number eq $boardno]/black/@player and
																	pairings/inning[$inningno]/rounds/round[@number eq $roundno]/boards/board[@number eq $boardno]/black/@player eq pairings/inning[$inningno+1]/rounds/round[@number eq $roundno]/boards/board[@number eq $boardno]/white/@player
																) else (
																	(: players given by 'player[@position]' :)
																	pairings/inning[$inningno]/rounds/round[@number eq $roundno]/boards/board[@number eq $boardno]/player[@position eq 1]/@id eq pairings/inning[$inningno+1]/rounds/round[@number eq $roundno]/boards/board[@number eq $boardno]/player[@position eq 2]/@id and
																	pairings/inning[$inningno]/rounds/round[@number eq $roundno]/boards/board[@number eq $boardno]/player[@position eq 2]/@id eq pairings/inning[$inningno+1]/rounds/round[@number eq $roundno]/boards/board[@number eq $boardno]/player[@position eq 1]/@id
																)
															)
														)
													)
												) else (true())" xerces:message="The colors of the same pairing must be alternating for every inning.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Werden mehrere Durchgänge gespielt, d.h.
							/tournament/settings/pairings/system[@type eq 'Round-Robin']/innings > 1,
							bzw. count(/tournament/settings/inning) > 0,
							so müssen sich die Farben der Spieler der selben
							Runde am selben Brett immer abwechseln.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="if (settings/pairings/system/color-of-first and settings/pairings/system[@type eq 'Swiss']/color-of-first ne 'random' and (pairings | pairings/inning[@number eq 1]/rounds)/round[@number eq 1][boards]) then (
													if (settings/pairings/system[@type eq 'Swiss']/color-of-first eq 'white') then (
														(pairings | pairings/inning[@number eq 1]/rounds)/round[@number eq 1]/boards/board[@number eq 1]/white/@player eq rankings/initial/player[@position eq 1]/@id
													) else (
														(pairings | pairings/inning[@number eq 1]/rounds)/round[@number eq 1]/boards/board[@number eq 1]/black/@player eq rankings/initial/player[@position eq 1]/@id
													)
												) else ( true() )" xerces:message="The player with seeding position 1 has to have the same color in the very first round as specified in /tournament/settings/pairings/system[@type eq 'Swiss']/color-of-first.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Der Spieler mit Startrangnummer 1 spieler in der
							allerersten Runde am ersten Brett mit eben jener
							Farbe, die in
							/tournament/settings/pairings/system[@type eq 'Swiss']/color-of-first
							angegeben wurde.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="tournament-team">
		<xs:complexContent>
			<xs:extension base="tournament">
				<xs:all>
					<xs:element name="teams" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Liste aller Teams.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:sequence>
								<xs:element name="team" minOccurs="1" maxOccurs="unbounded">
									<xs:complexType>
										<xs:sequence>
											<xs:element name="name">
												<xs:simpleType>
													<xs:restriction base="xs:string">
														<xs:minLength value="2" />
													</xs:restriction>
												</xs:simpleType>										
											</xs:element>

											<xs:element name="team-captain" type="xs:anyType" minOccurs="0">
												<xs:alternative test="count(@player) eq 1" type="team-captain-is-player" />
												<xs:alternative test="count(@player) eq 0" type="team-captain" />
											</xs:element>

											<xs:element name="identifiers" minOccurs="0">
												<xs:complexType>
													<xs:choice>
														<xs:annotation>
															<xs:documentation xml:lang="DE">
																Es kann entweder das Land angegeben werden (für eine
																Landesauswahl) oder der Verein (für eine Vereinsmannschaft).
																Alternativ kann das allgemeine 'organization' gewählt werden
																(etwa für die Schule, Landesverband, Betriebssportgemeinschaft).
															</xs:documentation>
														</xs:annotation>

														<xs:element name="federation">
															<xs:complexType>
																<xs:sequence>
																	<xs:element name="team-number" type="xs:positiveInteger" minOccurs="0">
																		<xs:annotation>
																			<xs:documentation xml:lang="DE">
																				Mannschaftsnummer, falls mehrere Mannschaften einer
																				Föderation teilnehmen.
																			</xs:documentation>
																		</xs:annotation>
																	</xs:element>
																</xs:sequence>

																<xs:attribute name="code" type="Country-Code" use="required" />
															</xs:complexType>
														</xs:element>

														<xs:element name="organization">
															<xs:annotation>
																<xs:documentation xml:lang="DE">
																	Bereichsauswahl, z.B. Betriebssportgemeinschaft,
																	Schule, Bezirk.
																</xs:documentation>
															</xs:annotation>

															<xs:complexType>
																<xs:sequence>
																	<xs:element name="name">
																		<xs:simpleType>
																			<xs:restriction base="xs:string">
																				<xs:minLength value="3" />
																			</xs:restriction>
																		</xs:simpleType>
																	</xs:element>

																	<xs:element name="team-number" type="xs:positiveInteger" minOccurs="0">
																		<xs:annotation>
																			<xs:documentation xml:lang="DE">
																				Mannschaftsnummer, falls mehrere Mannschaften eines
																				Bereichs antreten.
																				Optional.
																			</xs:documentation>
																		</xs:annotation>
																	</xs:element>
																</xs:sequence>
															</xs:complexType>
														</xs:element>

														<xs:element name="club" type="identifier-club">
															<xs:alternative test="@federation and (@federation eq 'GER' or @federation eq 'DE')" type="_t_team-identifier-club_GER" />
															<xs:alternative test="true()" type="_t_team-identifier-club" />
														</xs:element>
													</xs:choice>
												</xs:complexType>
											</xs:element>

											<xs:element name="locations" minOccurs="0">
												<xs:complexType>
													<xs:sequence>
														<xs:element name="location" maxOccurs="unbounded">
															<xs:annotation>
																<xs:documentation xml:lang="DE">
																	Zum Verein zugehörige Spielstätte.
																</xs:documentation>
															</xs:annotation>

															<xs:complexType>
																<xs:complexContent>
																	<xs:extension base="location">
																		<xs:attribute name="id" use="required" type="team-location-id" />
																	</xs:extension> 
																</xs:complexContent>
															</xs:complexType>
														</xs:element>
													</xs:sequence>

													<xs:assert test="every $i in 1 to count(location) satisfies 
																		(ends-with(location[$i]/@id, concat('-', $i)))" xerces:message="Location IDs must be serially numbered.">
														<xs:annotation>
															<xs:documentation xml:lang="DE">
																Bedingung (XSD1.1): Die Location-IDs sind aufsteigend
																durchnummeriert (enden mit "-$nummer").
															</xs:documentation>
														</xs:annotation>
													</xs:assert>
												</xs:complexType>
											</xs:element>

											<xs:element name="players">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Spieler dieser Mannschaft.
													</xs:documentation>
												</xs:annotation>

												<xs:complexType>
													<xs:sequence>
														<xs:element name="player" minOccurs="0" maxOccurs="unbounded">
															<xs:complexType>
																<xs:attribute name="id" type="xs:positiveInteger" use="required" />

																<xs:attribute name="position" type="xs:positiveInteger" />

																<xs:attribute name="guest" type="xs:boolean" />
															</xs:complexType>
														</xs:element>
													</xs:sequence>


													<xs:assert test="((count(player/@position) eq 0) or 
																		(every $i in 1 to count(player) satisfies (player[$i]/@position eq $i)))" xerces:message="The @position attribute must be set for either all or no players. The @position must be serially numbered if not empty.">
														<xs:annotation>
															<xs:documentation xml:lang="DE">
																Bedingung (XSD1.1): Entweder ist bei keinem Spieler das 
																"position"-Attribut gesetzt oder bei allen, dann aber
																aufsteigend durchnummeriert.
															</xs:documentation>
														</xs:annotation>
													</xs:assert>
												</xs:complexType>
											</xs:element>
										</xs:sequence>

										<xs:attribute name="id" type="xs:positiveInteger" use="required" />

										<xs:attribute name="inactive" type="xs:boolean" default="false" use="optional" />


										<xs:assert test="every $i in locations/location/@id satisfies starts-with($i, concat(@id, '-'))" xerces:message="The location @id must start with the team's id.">
											<xs:annotation>
												<xs:documentation xml:lang="DE">
													Bedingung (XSD1.1): Die Location-IDs beginnen mit der Team-ID.
												</xs:documentation>
											</xs:annotation>
										</xs:assert>
									</xs:complexType>
								</xs:element>
							</xs:sequence>


							<xs:assert test="every $i in 1 to count(team) satisfies (team[$i]/@id eq $i)" xerces:message="Teams must be serially numbered, beginning with 1.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Mannschaften sind aufsteigend durchnummeriert, beginnend bei 1.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>

							<xs:assert test="every $i in 1 to count(team)-1 satisfies (compare(lower-case(team[$i]/name), lower-case(team[$i+1]/name)) eq -1)" xerces:message="Teams must be sorted by their name.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Mannschaften sind aufsteigend sortiert nach Name, d.h. 
										team[$i]/name lt team[$i+1]/name.
								
										Achtung: Die Sortierung erfolgt abhängig von der Collation,
										d.h. standardmäßig 'a' lt 'z' lt 'ä' lt 'ö' lt 'ü'.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>

							<xs:assert test="count(team/players/player/@position) eq 0 or count(team/players/player/@position) eq count(team/players/player)" xerces:message="The @position attribute must be set for either all or no player in the team's players list.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Entweder sind alle Spieler in der Spielerliste mit dem @position Attribut
										versehen oder keiner.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>
						</xs:complexType>


						<xs:unique name="unique-team-name">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Bedingung (XSD1.0 kompatibel): Teamname muss eindeutig
									innerhalb eines Turniers sein.
								</xs:documentation>
							</xs:annotation>

							<xs:selector xpath="team" />
							<xs:field xpath="name" />
						</xs:unique>
					</xs:element>

					<xs:element name="pairings" minOccurs="0">
						<xs:complexType>
							<xs:choice>
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Im Allgemeinen beinhaltet das "pairings"-Element die "round"-Elemente.
										Handelt es sich jedoch um ein Rundenturnier (d.h. 
										/tournament/settings/pairings/system/@type = 'Round-Robin') und wird
										mehr als ein Durchgang (d.h. 
										/tournament/settings/pairings/system[@type eq 'Round-Robin']/innings gt 1)
										gespielt, so kommen auf dieser Ebene die "inning"-Elemente.
									</xs:documentation>
								</xs:annotation>

								<xs:sequence>
									<xs:element name="round" type="_t_round" maxOccurs="unbounded">
										<xs:unique name="_t_round-unique-team">
											<xs:annotation>
												<xs:documentation xml:lang="DE">
													Jede Mannschaft darf pro Runde nur einmal gepaart sein.
												</xs:documentation>
											</xs:annotation>

											<xs:selector xpath="tables/table/team" />
											<xs:field xpath="@id" />
										</xs:unique>
									</xs:element>
								</xs:sequence>

								<xs:sequence>
									<xs:element name="inning" maxOccurs="unbounded">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Durchgang. Beinhaltet mindestens information oder boards, 
												ist aber in keinem Fall leer.
											</xs:documentation>
										</xs:annotation>

										<xs:complexType>
											<xs:sequence>
												<xs:element name="information" type="pairing-information-single" minOccurs="0" />

												<xs:element name="notes" type="notes" minOccurs="0" />

												<xs:element name="rounds" minOccurs="0">
													<xs:complexType>
														<xs:sequence>
															<xs:element name="round" type="_t_round" maxOccurs="unbounded">
																<xs:unique name="_t_with-innings_round-unique-team">
																	<xs:annotation>
																		<xs:documentation xml:lang="DE">
																			Jede Mannschaft darf pro Runde nur einmal gepaart sein.
																		</xs:documentation>
																	</xs:annotation>

																	<xs:selector xpath="tables/table/team" />
																	<xs:field xpath="@id" />
																</xs:unique>
															</xs:element>
														</xs:sequence>
													</xs:complexType>
												</xs:element>
											</xs:sequence>
									
											<xs:attribute name="number" type="xs:positiveInteger" use="required" />
										</xs:complexType>
									</xs:element>
								</xs:sequence>
							</xs:choice>

							<xs:assert test="every $i in 1 to count(round) satisfies (round[$i]/@number = $i)" xerces:message="Rounds must be serially numbered, beginning with 1.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Rundennummern müssen aufsteigend durchnummeriert sein, beginnend bei 1.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>

							<xs:assert test="every $i in 1 to count(inning) satisfies (inning[$i]/@number = $i)" xerces:message="Inning numbers must be serially numbered, beginning with 1.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Durchgänge müssen aufsteigend durchnummeriert sein, beginnend bei 1.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>
						</xs:complexType>
					</xs:element>


					<xs:element name="settings">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Generelle, statische Turniereinstellungen.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:all>
								<xs:element name="general">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Allgemeine Turniereinstellungen wie Rundenzahl,
											Spieler pro Mannschaft, etc.
										</xs:documentation>
									</xs:annotation>

									<xs:complexType>
										<xs:sequence>
											<xs:element name="rounds" type="xs:positiveInteger">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Anzahl der Runden.
														Pflichtangabe.
													</xs:documentation>
												</xs:annotation>
											</xs:element>

											<xs:element name="games-per-round" type="xs:positiveInteger" minOccurs="0">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Partien pro Runde.
														Optional. Implizit 1.
													</xs:documentation>
												</xs:annotation>
											</xs:element>

											<xs:element name="boards">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Anzahl der Brettern, an denen ein Mannschaftskampf
														ausgetragen wird. Mindestens 2.
														Pflichtangabe.
													</xs:documentation>
												</xs:annotation>

												<xs:complexType>
													<xs:simpleContent>
														<xs:extension base="_t_number-of-boards">
															<xs:attribute name="colors" use="optional">
																<xs:annotation>
																	<xs:documentation xml:lang="DE">
																		Angabe der Farbverteilung als Liste von ("w"|"b")-Einträgen,
																		aus Sicht der erstgenannten Mannschaft.
																		Optional. Wenn angegeben, werden die Paarungen entsprechend
																		validiert. [TODO]
																	</xs:documentation>
																</xs:annotation>

																<xs:simpleType>
																	<xs:list>
																		<xs:simpleType>
																			<xs:restriction base="xs:string">
																				<xs:enumeration value="w" />
																				<xs:enumeration value="b" />
																			</xs:restriction>
																		</xs:simpleType>
																	</xs:list>
																</xs:simpleType>
															</xs:attribute>


															<xs:assert test="not(@colors) or count(tokenize(xs:string(@colors), ' ')) eq xs:integer(.)" xerces:message="The number of listed @colors must be equal to the number of boards.">
																<xs:annotation>
																	<xs:documentation xml:lang="DE">
																		Die Anzahl der angegebenen Farben entspricht der
																		angegebenen Brettanzahl.
																	</xs:documentation>
																</xs:annotation>
															</xs:assert>
														</xs:extension>
													</xs:simpleContent>
												</xs:complexType>
											</xs:element>

											<xs:element name="team-members" minOccurs="0">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Maximale Anzahl der Teammitglieder, optional.
														Zahlenwert oder "unbounded".
													</xs:documentation>
												</xs:annotation>

												<xs:simpleType>
													<xs:union memberTypes="xs:positiveInteger str_unbounded" />
												</xs:simpleType>
											</xs:element>
										</xs:sequence>

										<xs:assert test="if (count(team-members) eq 0 or xs:string(team-members) eq 'unbounded') then (true()) else (xs:integer(team-members) ge xs:integer(boards))" xerces:message="The maximal number of team-members must be greater or equal to the number of boards.">
											<xs:annotation>
												<xs:documentation xml:lang="DE">
													Die maximale Anzahl der Mannschaftsmitglieder darf die
													Zahl der Bretter nicht unterschreiten.
												</xs:documentation>
											</xs:annotation>
										</xs:assert>
									</xs:complexType>
								</xs:element>

								<xs:element name="pairings" minOccurs="0">
									<xs:complexType>
										<xs:all>
											<xs:element name="system" type="_t_pairings-system" minOccurs="0">
												<xs:alternative type="_t_pairings-system-Swiss" test="@type eq 'Swiss'" />
												<xs:alternative type="_t_pairings-system-Round-Robin" test="@type eq 'Round-Robin'" />
											</xs:element>

											<xs:element name="constraints" minOccurs="0">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Randbedingungen zur Ermittlung der Mannschaftspaarungen, etwa
														feste Tischnummern oder Angabe der Runden, in denen
														einzelne Mannschaften aussetzen.
													</xs:documentation>
												</xs:annotation>

												<xs:complexType>
													<xs:all>
														<xs:element name="teams">
															<xs:complexType>
																<xs:sequence>
																	<xs:element name="team" maxOccurs="unbounded">
																		<xs:annotation>
																			<xs:documentation xml:lang="DE">
																				Informationen zu einer Mannschaft, die nur die Paarungen
																				betreffen, und somit nicht in /tournament/teams/team
																				gehören.
																			</xs:documentation>
																		</xs:annotation>

																		<xs:complexType>
																			<xs:all>
																				<xs:element name="fixed-table" type="xs:positiveInteger" minOccurs="0">
																					<xs:annotation>
																						<xs:documentation xml:lang="DE">
																							Feste Tischnummer.
																						</xs:documentation>
																					</xs:annotation>
																				</xs:element>

																				<xs:element name="not-paired" minOccurs="0">
																					<xs:annotation>
																						<xs:documentation xml:lang="DE">
																							Angabe der Runden, in denen eine Mannschaft aussetzt.
																						</xs:documentation>
																					</xs:annotation>

																					<xs:complexType>
																						<xs:sequence>
																							<xs:element name="round" type="xs:positiveInteger" maxOccurs="unbounded" />
																						</xs:sequence>


																						<xs:assert test="every $i in 1 to count(round)-1 satisfies (xs:integer(round[$i]) lt xs:integer(round[$i+1]))" xerces:message="Rounds must be listed in ascending order.">
																							<xs:annotation>
																								<xs:documentation xml:lang="DE">
																									Angegebene Runden sind aufsteigend sortiert.
																								</xs:documentation>
																							</xs:annotation>
																						</xs:assert>
																					</xs:complexType>
																				</xs:element>
																			</xs:all>

																			<xs:attribute name="id" type="xs:positiveInteger" use="required" />
																		</xs:complexType>
																	</xs:element>
																</xs:sequence>


																<xs:assert test="every $i in 1 to count(team)-1 satisfies (xs:integer(team[$i]/@id) lt xs:integer(team[$i+1]/@id))" xerces:message="Teams must be listed in ascending order of their IDs.">
																	<xs:annotation>
																		<xs:documentation xml:lang="DE">
																			Angegebene Teams sind aufsteigend nach ihrer ID sortiert.
																		</xs:documentation>
																	</xs:annotation>
																</xs:assert>
															</xs:complexType>

															<xs:unique name="_t_constraints-teams_unique-fixed-table">
																<xs:annotation>
																	<xs:documentation xml:lang="DE">
																		Jede feste Tischnummer kann nur genau einmal vergeben werden.
																	</xs:documentation>
																</xs:annotation>

																<xs:selector xpath="team" />
																<xs:field xpath="fixed-table" />
															</xs:unique>
														</xs:element>
													</xs:all>
												</xs:complexType>
											</xs:element>
										</xs:all>
									</xs:complexType>
								</xs:element>

								<xs:element name="points-system" minOccurs="0">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Verwendetes Punktesystem
										</xs:documentation>
									</xs:annotation>

									<xs:complexType>
										<xs:all>
											<xs:element name="individuals" type="game-points-individual" minOccurs="0">
												<xs:unique name="t_unique-game-points-individuals_win">
													<xs:selector xpath="win" />
													<xs:field xpath="@attribute" />
													<xs:field xpath="@color" />
												</xs:unique>
												<xs:unique name="t_unique-game-points-individuals_draw">
													<xs:selector xpath="draw" />
													<xs:field xpath="@attribute" />
													<xs:field xpath="@color" />
												</xs:unique>
												<xs:unique name="t_unique-game-points-individuals_loss">
													<xs:selector xpath="loss" />
													<xs:field xpath="@attribute" />
													<xs:field xpath="@color" />
												</xs:unique>
											</xs:element>

											<xs:element name="teams" type="game-points-team" minOccurs="0">
												<xs:unique name="t_unique-game-points-teams_win">
													<xs:selector xpath="win" />
													<xs:field xpath="@attribute" />
												</xs:unique>
												<xs:unique name="t_unique-game-points-teams_draw">
													<xs:selector xpath="draw" />
													<xs:field xpath="@attribute" />
												</xs:unique>
												<xs:unique name="t_unique-game-points-teams_loss">
													<xs:selector xpath="loss" />
													<xs:field xpath="@attribute" />
												</xs:unique>
											</xs:element>
										</xs:all>
									</xs:complexType>
								</xs:element>

								<xs:element name="rankings" minOccurs="0">
									<xs:complexType>
										<xs:sequence>
											<xs:element name="initial" minOccurs="0">
												<xs:complexType>
													<xs:all>
														<xs:element name="criteria">
															<xs:annotation>
																<xs:documentation xml:lang="DE">
																	Kriterien zur Bildung der Startliste.
																</xs:documentation>
															</xs:annotation>

															<xs:complexType>
																<xs:sequence>
																	<xs:element name="criterion" type="_t_initial-ranking-criterion" maxOccurs="unbounded">
																		<xs:alternative test="@type eq 'Rating'" type="_t_initial-ranking-criterion-Rating" />
																		<xs:alternative test="@type eq 'Custom'" type="_t_initial-ranking-criterion-Custom" />

																		<xs:alternative test="true()" type="_t_initial-ranking-criterion" />
																	</xs:element>
																</xs:sequence>

																<xs:assert test="every $i in 1 to count(criterion) satisfies (criterion[$i]/@number eq $i)" xerces:message="Criteria must be serially numbered, beginning with 1">
																	<xs:annotation>
																		<xs:documentation xml:lang="DE">
																			Die Kriterien müssen über ihr @number Attribut aufsteigend
																			nummeriert sein, beginnend bei 1.
																		</xs:documentation>
																	</xs:annotation>
																</xs:assert>

																<xs:assert test="empty(criterion[@type eq 'Random']) or criterion[@type eq 'Random']/@number eq criterion[position() eq last()]/@number" xerces:message="Criterion 'Random' could only be the last one.">
																	<xs:annotation>
																		<xs:documentation xml:lang="DE">
																			"Random" kann nur das letzte Kriterium sein.
																		</xs:documentation>
																	</xs:annotation>
																</xs:assert>
															</xs:complexType>


															<xs:unique name="_t_initial-ranking-criteria_unique-custom-names">
																<xs:annotation>
																	<xs:documentation xml:lang="DE">
																		Der in criterion/name genannte Name von selbst definierten
																		Feinwertungen ist eindeutig.
																	</xs:documentation>
																</xs:annotation>

																<xs:selector xpath="criterion" />
																<xs:field xpath="name" />
															</xs:unique>
															<xs:unique name="_t_intial-ranking-criteria_unique-custom-abbreviation">
																<xs:annotation>
																	<xs:documentation xml:lang="DE">
																		Die in criterion/name/@abbreviation genannte Abkürzung von 
																		selbst definierten Feinwertungen ist eindeutig.
																	</xs:documentation>
																</xs:annotation>

																<xs:selector xpath="criterion" />
																<xs:field xpath="name/@abbreviation" />
															</xs:unique>
														</xs:element>
													</xs:all>
												</xs:complexType>
											</xs:element>

											<xs:element name="rounds" minOccurs="0">
												<xs:complexType>
													<xs:all>
														<xs:element name="teams" minOccurs="0">
															<xs:complexType>
																<xs:all>
																	<xs:element name="criteria">
																		<xs:annotation>
																			<xs:documentation xml:lang="DE">
																				Wertungen zur Bildung der Rangliste von Mannschaften.
																			</xs:documentation>
																		</xs:annotation>

																		<xs:complexType>
																			<xs:sequence>
																				<xs:element name="criterion" type="_t_rounds-ranking-criterion" maxOccurs="unbounded">
																					<xs:alternative test="@type eq 'Buchholz'" type="_t_rounds-ranking-criterion-Buchholz" />
																					<xs:alternative test="@type eq 'Direct-Encounter'" type="_t_rounds-ranking-criterion-Direct-Encounter" />
																					<xs:alternative test="@type eq 'Custom'" type="_t_rounds-ranking-criterion-Custom" />

																					<xs:alternative test="true()" type="_t_rounds-ranking-criterion" />
																				</xs:element>
																			</xs:sequence>

																			<xs:assert test="every $i in 1 to count(criterion) satisfies (criterion[$i]/@number eq $i)" xerces:message="Criteria must be serially numbered, beginning with 1">
																				<xs:annotation>
																					<xs:documentation xml:lang="DE">
																						Die Kriterien müssen über ihr @number Attribut aufsteigend
																						nummeriert sein, beginnend bei 1.
																					</xs:documentation>
																				</xs:annotation>
																			</xs:assert>

																			<xs:assert test="empty(criterion[@type eq 'Random']) or criterion[@type eq 'Random']/@number eq criterion[position() eq last()]/@number" xerces:message="Criterion 'Random' could only be the last one.">
																				<xs:annotation>
																					<xs:documentation xml:lang="DE">
																						"Random" kann nur das letzte Kriterium sein.
																					</xs:documentation>
																				</xs:annotation>
																			</xs:assert>
																		</xs:complexType>


																		<xs:unique name="_t_rounds-ranking-criteria_unique-custom-names">
																			<xs:annotation>
																				<xs:documentation xml:lang="DE">
																					Der in criterion/name genannte Name von selbst definierten
																					Feinwertungen ist eindeutig.
																				</xs:documentation>
																			</xs:annotation>

																			<xs:selector xpath="criterion" />
																			<xs:field xpath="name" />
																		</xs:unique>
																		<xs:unique name="_t_rounds-ranking-criteria_unique-custom-abbreviation">
																			<xs:annotation>
																				<xs:documentation xml:lang="DE">
																					Die in criterion/name/@abbreviation genannte Abkürzung von 
																					selbst definierten Feinwertungen ist eindeutig.
																				</xs:documentation>
																			</xs:annotation>

																			<xs:selector xpath="criterion" />
																			<xs:field xpath="name/@abbreviation" />
																		</xs:unique>
																	</xs:element>
																</xs:all>
															</xs:complexType>
														</xs:element>

														<xs:element name="individuals" minOccurs="0">
															<xs:complexType>
																<xs:all>
																	<xs:element name="criteria" type="individual-rounds-ranking-criteria">
																		<xs:annotation>
																			<xs:documentation xml:lang="DE">
																				Wertungen zur Bildung der Rangliste von Einzelspielern.
																			</xs:documentation>
																		</xs:annotation>

																		<xs:unique name="_t_individual-rounds-ranking-criteria_unique-custom-names">
																			<xs:annotation>
																				<xs:documentation xml:lang="DE">
																					Der in criterion/name genannte Name von selbst definierten
																					Feinwertungen ist eindeutig.
																				</xs:documentation>
																			</xs:annotation>

																			<xs:selector xpath="criterion" />
																			<xs:field xpath="name" />
																		</xs:unique>

																		<xs:unique name="_t_individual-rounds-ranking-criteria_unique-custom-abbreviation">
																			<xs:annotation>
																				<xs:documentation xml:lang="DE">
																					Die in criterion/name/@abbreviation genannte Abkürzung von 
																					selbst definierten Feinwertungen ist eindeutig.
																				</xs:documentation>
																			</xs:annotation>

																			<xs:selector xpath="criterion" />
																			<xs:field xpath="name/@abbreviation" />
																		</xs:unique>
																	</xs:element>
																</xs:all>
															</xs:complexType>
														</xs:element>
													</xs:all>
												</xs:complexType>
											</xs:element>
										</xs:sequence>
									</xs:complexType>
								</xs:element>
							</xs:all>
						</xs:complexType>
					</xs:element>


					<xs:element name="rankings" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Turnierranglisten, insbesondere auch die Startrangliste, welche
								mindestens hinterlegt sein muss.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:sequence>
								<xs:element name="initial">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Startrangliste der Mannschaften.
										</xs:documentation>
									</xs:annotation>

									<xs:complexType>
										<xs:sequence>
											<xs:element name="team" minOccurs="0" maxOccurs="unbounded">
												<xs:complexType>
													<xs:attribute name="position" type="xs:positiveInteger" use="required" />

													<xs:attribute name="id" type="xs:positiveInteger" use="required" />
												</xs:complexType>
											</xs:element>
										</xs:sequence>

										<xs:assert test="every $i in 1 to count(team) satisfies (team[$i]/@position eq $i)" xerces:message="The positions in team/@position must be serially numbered, beginning with 1.">
											<xs:annotation>
												<xs:documentation xml:lang="DE">
													Die Positionen in team/@position sind aufsteigend
													durchnummeriert, beginnend bei 1.
												</xs:documentation>
											</xs:annotation>
										</xs:assert>
									</xs:complexType>

									<xs:unique name="unique-rankings-initial-team-position">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Die angegebenen Positionen müssen in der Startrangliste 
												(im Gegensatz zu herkömmlichen Ranglisten) eindeutig sein.
											</xs:documentation>
										</xs:annotation>

										<xs:selector xpath="team" />
										<xs:field xpath="@position" />
									</xs:unique>

									<xs:unique name="unique-rankings-initial-team-id">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Die angegebenen Mannschaften dürfen nur einmal in der 
												Startrangliste geführt werden.
											</xs:documentation>
										</xs:annotation>

										<xs:selector xpath="team" />
										<xs:field xpath="@id" />
									</xs:unique>
								</xs:element>

								<xs:choice minOccurs="0">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Für jede Runde kann eine Rangliste gespeichert werden.
											Handelt es sich um ein Rundenturnier mit mehr als einem
											Durchgang, d.h.
											/tournament/settings/pairings/system[@type eq 'Round-Robin']/innings > 1,
											sind die 'inning' die Kindelemente, ansonsten 'round'.
										</xs:documentation>
									</xs:annotation>

									<xs:element name="rounds">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Für jede Runde kann eine Rangliste gespeichert werden.
												Diese muss mindestens die Team-Rangliste round/teams und 
												kann zusätzlich die Spieler-Rangliste round/players 
												enthalten.
											</xs:documentation>
										</xs:annotation>

										<xs:complexType>
											<xs:sequence>
												<xs:element name="round" type="_t_ranking-round" maxOccurs="unbounded" />
											</xs:sequence>
										</xs:complexType>
									</xs:element>

									<xs:element name="innings">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Tür Turniere mit mehreren Durchgängen.
											</xs:documentation>
										</xs:annotation>

										<xs:complexType>
											<xs:sequence>
												<xs:element name="inning" maxOccurs="unbounded">
													<xs:complexType>
														<xs:sequence>
															<xs:element name="rounds">
																<xs:complexType>
																	<xs:sequence>
																		<xs:element name="round" type="_t_ranking-round" maxOccurs="unbounded" />
																	</xs:sequence>
																</xs:complexType>
															</xs:element>
														</xs:sequence>

														<xs:attribute name="number" type="xs:positiveInteger" use="required" />
													</xs:complexType>
												</xs:element>
											</xs:sequence>
										</xs:complexType>
									</xs:element>
								</xs:choice>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:all>


				<xs:assert test="every $i in players/player/@id satisfies (count(teams/team/players/player[@id eq $i]) ge 1)" xerces:message="Every player must be referenced by at least one team.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Bedingung (XSD1.1): Jeder Spieler wird in mindestens einem Team referenziert.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="every $player in pairings//round/tables/table/boards/board/(white | black | player) satisfies (
										count(teams/team[@id eq $player/@team]/players/player[@id eq $player/(@player | @id)]) eq 1
									)" xerces:message="Each player must be listed by its player-id and corresponding team-id.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Jeder Spieler, der in den Einzelpaarungen, d.h. unter
							/tournament/pairings/round/tables/table/boards/board/{white,black}
							aufgeführt ist, muss auch der über @team angegebenen Mannschaft 
							zugehörig sein.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="if (count(teams/team/players/player/@position) gt 0) then (
														(: players are ordered within their teams :)
													every 
														$table in pairings/round/tables/table[count(boards/board) ge 2],
															(: loop through every table with more than two boards :)
														$board in 1 to count($table/boards/board[position() lt last()]),
															(: loop through all boards except the last one :)
														$team in $table/boards/board[$board]/(white | black | player)/@team,
															(: validate for the team of the white and black player of this $board :)
														$compare in ($board+1) to count($table/boards/board)
															(: loop through all following boards on this table :)
													satisfies (
														(
															( 
																xs:string($table/boards/board[$compare]/(white | black | player)[@team eq $team]/@seeded-too-low) eq 'true'
																	(: ignore if the @seeded-too-low attribute is set to true for the compared player :)
															) or ( 
																teams/team[@id eq $team]/players/player[@id eq $table/boards/board[$board]/((white | black)[@team eq $team]/@player | player[@team eq $team]/@id)]/@position lt teams/team[@id eq $team]/players/player[@id eq $table/boards/board[$compare]/((white | black)[@team eq $team]/@player | player[@team eq $team]/@id)]/@position
																	(: the position of the player on board $board must be lower than the one of the player on board $compare :)
															)
														)
													)
												) else ( true() )" xerces:message="The players must be seeded in the right order. Otherwise you have to mark every player seeded too low with the @seeded-too-low='true' attribute.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Falls in teams/team/players/player das @position Attribut gesetzt wurde,
							müssen die Spieler einer Mannschaft in den Einzelpaarungen in der
							korrekten Reihenfolge eingesetzt werden, d.h. kein Spieler kann vor einem
							anderen eingesetzt werden, der mit einem niedrigeren @position Attribut
							in der Mannschafts-Spielerliste aufgeführt wurde.
							Spieler, die zu tief eingesetzt wurden, können mit einem @seeded-too-low="true"
							von der Validierung ausgenommen werden.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="every $table in pairings//round/tables/table[boards] satisfies (count($table/boards/board) eq xs:integer(settings/general/boards))" xerces:message="The number of boards given in /tournament/pairings//round/tables/boards must be equal to the saved one in /tournament/settings/general/boards">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Die Anzahl der in /tournament/pairings//round/tables/table[boards]
							angegebenen Einzelbretter muss der in /tournament/settings/general/boards
							angegebenen Mannschaftsstärke entsprechen.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="every $team in pairings//round/tables/table/results/team satisfies (sum($team/*) le xs:integer(settings/general/boards))" xerces:message="The number of results given in /tournament/pairings//round/tables/results/team must be less or equal to the specified number of boards in /tournament/settings/general/boards">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Die in /tournament/pairings/round/tables/table/results/team
							angegebenen Einzelergebnisse dürfen in der Summe nicht die in
							/tournament/settings/general/boards angegebene Mannschaftsstärke
							überschreiten.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="every $id in teams/team/@id satisfies ( count(rankings/initial/team[@id eq $id]) eq 1 )" xerces:message="Every team listed in /tournament/teams must also be listed in the initial ranking.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Jede in /tournament/teams gelistete Mannschaft 
							ist auch in der Startrangliste einmal aufgeführt.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="if (count(pairings/inning) gt 0) then (
													every $roundno in pairings/inning[1]/rounds/round[tables]/@number satisfies (
														every $tableno in pairings/inning[1]/rounds/round[@number eq $roundno]/tables/table/@number satisfies (
															every $team in pairings/inning[1]/rounds/round[@number eq $roundno]/tables/table[@number eq $tableno]/team/@id satisfies (
																count(pairings/inning/rounds/round[@number eq $roundno]/tables/table[@number eq $tableno]/team[@id eq $team]) eq settings/pairings/system[@type eq 'Round-Robin']/innings
															)
														)
													)
												) else (true())" xerces:message="The competiting teams on a specific table in a specific round must be the same in all innings.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Wurde eine Runde in einem Turnier mit mehreren Durchgängen
							bereits ausgelost, d.h. in
							pairings/inning/rounds/round existiert das Kindelement 'tables',
							so sind an den Paarungen an einem spezifischen Tisch in einer
							bestimmten Runde auch immer die gleichen Mannschaften beteiligt.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="if (count(pairings/inning) gt 0) then (
													every $inningno in 1 to count(pairings/inning)-1 satisfies (
														every $roundno in pairings/inning[$inningno]/rounds/round[tables]/@number satisfies (
															every $tableno in pairings/inning[$inningno]/rounds/round[@number eq $roundno]/tables/table/@number satisfies (
																pairings/inning[$inningno]/rounds/round[@number eq $roundno]/tables/table[@number eq $tableno]/team[@position eq 1]/@id eq pairings/inning[$inningno+1]/rounds/round[@number eq $roundno]/tables/table[@number eq $tableno]/team[@position eq 2]/@id and
																pairings/inning[$inningno]/rounds/round[@number eq $roundno]/tables/table[@number eq $tableno]/team[@position eq 2]/@id eq pairings/inning[$inningno+1]/rounds/round[@number eq $roundno]/tables/table[@number eq $tableno]/team[@position eq 1]/@id
															)
														)
													)
												) else (true())" xerces:message="The positions of the same pairing must be alternating for every inning.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Werden mehrere Durchgänge gespielt, d.h.
							/tournament/settings/pairings/system[@type eq 'Round-Robin']/innings > 1,
							bzw. count(/tournament/settings/inning) > 0,
							so müssen sich die Farben der Spieler der selben
							Runde am selben Brett immer abwechseln.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="if (settings/general/boards/@colors) then (
													every $table in (pairings | pairings/inning[@number mod 2 eq 1]/rounds)/round/tables/table[boards] satisfies (
														every $boardno in 1 to count($table/boards/board) satisfies (
															if (tokenize(xs:string(settings/general/boards/@colors), ' ')[$boardno] eq 'w') then (
																$table/boards/board[$boardno]/(black | player[2])/@team eq $table/team[@position eq 2]/@id and
																$table/boards/board[$boardno]/(white | player[1])/@team eq $table/team[@position eq 1]/@id
															) else (
																$table/boards/board[$boardno]/(black | player[2])/@team eq $table/team[@position eq 1]/@id and
																$table/boards/board[$boardno]/(white | player[1])/@team eq $table/team[@position eq 2]/@id
															)
														)
													)
												) else ( true() )" xerces:message="The players must have the colors according to the listing in /tournament/settings/general/boards/@colors.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Wurde unter /tournament/settings/general/boards/@colors
							die Farbverteilung in den Mannschaftskämpfen angegeben,
							so muss diese in den einzelnen Begegnungen eingehalten
							werden.
							Bei Turnieren mit mehreren Durchgängen werden nur die
							geradzahligen Durchgänge validiert.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="if (settings/pairings/system/position-of-first and settings/pairings/system[@type eq 'Swiss']/position-of-first ne 'random' and (pairings | pairings/inning[@number eq 1]/rounds)/round[@number eq 1][tables]) then (
													if (settings/pairings/system[@type eq 'Swiss']/position-of-first eq 1) then (
														(pairings | pairings/inning[@number eq 1]/rounds)/round[@number eq 1]/tables/table[@number eq 1]/team[@position eq 1]/@id eq rankings/initial/team[@position eq 1]/@id
													) else (
														(pairings | pairings/inning[@number eq 1]/rounds)/round[@number eq 1]/tables/table[@number eq 1]/team[@position eq 2]/@id eq rankings/initial/team[@position eq 1]/@id
													)
												) else ( true() )" xerces:message="The team with seeding position 1 has to have the same color in the very first round as specified in /tournament/settings/pairings/system[@type eq 'Swiss']/position-of-first.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Die Mannschaft mit Startrangnummer 1 ist in der
							allerersten Runde am ersten Tisch auf eben jener Position
							gesetzt, die in
							/tournament/settings/pairings/system[@type eq 'Swiss']/position-of-first
							angegeben wurde.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="if (settings/general/team-members and xs:string(settings/general/team-members) ne 'unbounded') then (
													every $team in teams/team satisfies(
														count($team/players/player) le xs:integer(settings/general/team-members)
													)
												) else (true())" xerces:message="The number of players of each team must be less or equal to the number specified in /tournament/settings/general/team-members.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Die Anzahl der Spieler pro Mannschaft darf die in
							/tournament/settings/general/team-members genannte
							Zahl nicht überschreiten.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="every $federation_code in distinct-values(data(teams/team/identifiers/federation/@code)) satisfies (
													if (count(teams/team/identifiers/federation[xs:string(@code) eq xs:string($federation_code)]) eq 1) then (
														true()
													) else (
														count(teams/team/identifiers/federation[xs:string(@code) eq xs:string($federation_code)][not(team-number)]) eq 0
													)
												)" xerces:message="If more than one team is sent by a federation, all of its teams must be numbered by their 'team-number' element.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Treten mehrere Mannschaften einer Föderation an,
							sind alle über identifiers/federation/team-number
							zu nummerieren.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="every $organization_name in distinct-values(data(teams/team/identifiers/organization/name)) satisfies (
													if (count(teams/team/identifiers/organization[xs:string(name) eq xs:string($organization_name)]) eq 1) then (
														true()
													) else (
														count(teams/team/identifiers/organization[xs:string(name) eq xs:string($organization_name)][not(team-number)]) eq 0
													)
												)" xerces:message="If more than one team is sent by a organization, all of its teams must be numbered by their 'team-number' element.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Treten mehrere Mannschaften eines Bereichs an,
							sind alle über identifiers/organization/team-number
							zu nummerieren.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="every $club_name in distinct-values(data(teams/team/identifiers/club/name)) satisfies (
													if (count(teams/team/identifiers/club[xs:string(name) eq xs:string($club_name)]) eq 1) then (
														true()
													) else (
														count(teams/team/identifiers/club[xs:string(name) eq xs:string($club_name)][not(team-number)]) eq 0
													)
												)" xerces:message="If more than one team is sent by a club, all of its teams must be numbered by their 'team-number' element.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Treten mehrere Mannschaften eines Vereins an,
							sind alle über identifiers/club/team-number
							zu nummerieren.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	
	<xs:simpleType name="tournament-name-entity">
		<xs:restriction base="xs:string">
			<xs:minLength value="3" />
		</xs:restriction>
	</xs:simpleType>

	<xs:complexType name="tournament-name">
		<xs:simpleContent>
			<xs:extension base="tournament-name-entity">
				<xs:attribute name="abbreviation" type="xs:string" use="optional">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Turnierabkürzung.
							Optional.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>


	<xs:complexType name="person-identifiers">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Mitgliedsnummer bei Verbänden, etwa FIDE und DSB
			</xs:documentation>
		</xs:annotation>

		<xs:sequence>
			<xs:element name="fide" minOccurs="0">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="id">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									FIDE-ID sieben- oder achtstellig
								</xs:documentation>
							</xs:annotation>

							<xs:simpleType>
								<xs:restriction base="xs:positiveInteger">
									<xs:minInclusive value="1000000" />
									<xs:maxExclusive value="100000000" />
								</xs:restriction>
							</xs:simpleType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>

			<xs:element name="federation" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Föderation, für welche der Spieler (gem. Fide) aktiv ist.
					</xs:documentation>
				</xs:annotation>

				<xs:complexType>
					<xs:sequence>
						<xs:element name="id" minOccurs="0">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:minLength value="1" />
								</xs:restriction>
							</xs:simpleType>
						</xs:element>
					</xs:sequence>

					<xs:attribute name="code" type="Country-Code" use="required" />
				</xs:complexType>
			</xs:element>

			<xs:element name="club" type="identifier-club" minOccurs="0" maxOccurs="1">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Für jeden Spieler kann seine (einzige aktive) Vereinszugehörigkeit
						gespeichert werden.
					</xs:documentation>
				</xs:annotation>

				<xs:alternative test="@federation and (@federation eq 'GER' or @federation eq 'DE')" type="player-identifier-club_GER" />
				<xs:alternative test="true()" type="player-identifier-club" />
			</xs:element>
		</xs:sequence>
	</xs:complexType>


	<xs:simpleType name="team-location-id">
		<xs:restriction base="xs:string">
			<xs:pattern value="[1-9][0-9]*\-[1-9][0-9]*" />
		</xs:restriction>
	</xs:simpleType>


	<xs:complexType name="address">
		<xs:sequence>
			<xs:element name="name" type="xs:string" minOccurs="0" />
			<xs:element name="street" type="xs:string" />
			<xs:element name="zip" type="xs:string" minOccurs="0" />
			<xs:element name="city" type="xs:string" />
			<xs:element name="country" type="xs:string" minOccurs="0" />
			<xs:element name="coordinates" type="coordinates" minOccurs="0">
				<xs:alternative test="(@type = 'WGS84' or (count(@type) eq 0))" type="coordinates-WGS84" />
			</xs:element>
		</xs:sequence>
	</xs:complexType>


	<xs:complexType name="location">
		<xs:sequence>
			<xs:element name="name" type="xs:string" />

			<xs:element name="address" type="address" minOccurs="0" />

			<xs:element name="phone" type="xs:string" minOccurs="0" />

			<xs:element name="information" minOccurs="0">
				<xs:complexType>
					<xs:all>
						<xs:element name="catering" type="xs:boolean" minOccurs="0" />
						<xs:element name="disabled-friendly" type="xs:boolean" minOccurs="0" />
					</xs:all>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>


	<xs:complexType name="coordinates">
		<xs:attribute name="type" default="WGS84">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="WGS84" />
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="coordinates-WGS84">
		<xs:complexContent>
			<xs:extension base="coordinates">
				<xs:all>
					<xs:element name="lon">
						<xs:simpleType>
							<xs:restriction base="xs:decimal">
								<xs:minInclusive value="-180" />
								<xs:maxInclusive value="180" />
							</xs:restriction>
						</xs:simpleType>
					</xs:element>
					<xs:element name="lat">
						<xs:simpleType>
							<xs:restriction base="xs:decimal">
								<xs:minInclusive value="-90" />
								<xs:maxInclusive value="90" />
							</xs:restriction>
						</xs:simpleType>
					</xs:element>
				</xs:all>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:simpleType name="str_FIDE">
		<xs:restriction base="xs:string">
			<xs:enumeration value="FIDE" />
		</xs:restriction>
	</xs:simpleType>

	<xs:simpleType name="arbiter-licence-entity">
		<xs:restriction base="xs:string">
			<xs:minLength value="1" />
		</xs:restriction>
	</xs:simpleType>

	<xs:complexType name="arbiter-licence">
		<xs:simpleContent>
			<xs:extension base="arbiter-licence-entity">
				<xs:attribute name="federation">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Verband, der die Lizenz ausgestellt hat / in dem die Lizenz gültig ist.
						</xs:documentation>
					</xs:annotation>

					<xs:simpleType>
						<xs:union memberTypes="Country-Code str_FIDE" />
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>

	<xs:complexType name="arbiter-licence-federation-FIDE">
		<xs:simpleContent>
			<xs:restriction base="arbiter-licence">
				<xs:enumeration value="FA">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							FIDE-Schiedsrichter
						</xs:documentation>
					</xs:annotation>
				</xs:enumeration>
				<xs:enumeration value="IA">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Internationaler Schiedsrichter
						</xs:documentation>
					</xs:annotation>
				</xs:enumeration>
			</xs:restriction>
		</xs:simpleContent>
	</xs:complexType>

	<xs:complexType name="arbiter-licence-federation-GER">
		<xs:simpleContent>
			<xs:restriction base="arbiter-licence">
				<xs:enumeration value="NSR">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Nationaler Schiedsrichter
						</xs:documentation>
					</xs:annotation>
				</xs:enumeration>
				<xs:enumeration value="RSR">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Regionaler Schiedsrichter
						</xs:documentation>
					</xs:annotation>
				</xs:enumeration>
				<xs:enumeration value="TL">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Turnierleiter
						</xs:documentation>
					</xs:annotation>
				</xs:enumeration>
			</xs:restriction>
		</xs:simpleContent>
	</xs:complexType>


	<xs:simpleType name="rating-system">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Elo" />
			<xs:enumeration value="DWZ" />
			<xs:enumeration value="" />
		</xs:restriction>
	</xs:simpleType>

	<xs:complexType name="rating-system-ranking">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Erweitert "rating-system" um das Attribut @on-empty, das 
				zur Startranglistenbildung angegeben werden kann.
			</xs:documentation>
		</xs:annotation>

		<xs:simpleContent>
			<xs:extension base="rating-system">
				<xs:attribute name="on-empty" use="optional">
					<xs:simpleType>
						<xs:union memberTypes="xs:integer">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Verfügt einer der bei der Durchschnittsberechnung betrachteten Spieler
									über keine Zahl in diesem Wertungssystem, kann hierüber eine 
									Pseudowertungszahl (xs:integer) angegeben werden.
								</xs:documentation>
							</xs:annotation>
						</xs:union>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>


	<xs:complexType name="rating">
		<xs:simpleContent>
			<xs:extension base="xs:integer">
				<xs:attribute name="type" type="rating-system" use="optional" default="" />

				<xs:attribute name="estimated" type="xs:boolean" use="optional" default="false">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Flag, ob die Wertungszahl durch die Turnierleitung geschätzt
							wurde.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>

	<xs:complexType name="rating-Elo">
		<xs:simpleContent>
			<xs:restriction base="rating">
				<xs:minInclusive value="400" />
				<xs:maxInclusive value="3500" />
			</xs:restriction>
		</xs:simpleContent>
	</xs:complexType>

	<xs:complexType name="rating-DWZ">
		<xs:simpleContent>
			<xs:restriction base="rating">
				<xs:minInclusive value="400" />
				<xs:maxInclusive value="3500" />
			</xs:restriction>
		</xs:simpleContent>
	</xs:complexType>


	<xs:complexType name="pairing-information">
		<xs:sequence>
			<xs:sequence minOccurs="0">
				<xs:element name="date" type="xs:date" />
				<xs:element name="time" type="xs:time" minOccurs="0" />
			</xs:sequence>			
		</xs:sequence>
	</xs:complexType>

	<xs:complexType name="pairing-information-single">
		<xs:complexContent>
			<xs:extension base="pairing-information">
				<xs:sequence>
					<xs:element name="location" type="location" minOccurs="0" />
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="pairing-information-team">
		<xs:complexContent>
			<xs:extension base="pairing-information">
				<xs:sequence>
					<xs:choice minOccurs="0">
						<xs:element name="location" type="location" />

						<xs:element name="host">
							<xs:complexType>
								<xs:attribute name="team" type="xs:integer" use="required" />

								<xs:attribute name="location" type="team-location-id" use="required" />

								<xs:assert test="substring-before(@location, '-') eq xs:string(@team)" xerces:message="Location must start with the team id.">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Bedingung (XSD1.1): Angegebene Location gehört zum 
											angegebenen Team.
										</xs:documentation>
									</xs:annotation>
								</xs:assert>
							</xs:complexType>
						</xs:element>
					</xs:choice>

					<xs:element name="arbiters" type="xs:anyType" minOccurs="0">
						<xs:alternative test="@type and @type eq 'string'" type="arbiters-string">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Aus Kompatibilitätsgründen.
								</xs:documentation>
							</xs:annotation>
						</xs:alternative>

						<xs:alternative test="true()" type="arbiters-reference-complex" />
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="simple-time">
		<xs:simpleContent>
			<xs:extension base="xs:float">
				<xs:attribute name="unit">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="hours" />
							<xs:enumeration value="minutes" />
							<xs:enumeration value="seconds" />
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>

	<xs:simpleType name="fide-title">
		<xs:restriction base="xs:string">
			<xs:enumeration value="GM" />
			<xs:enumeration value="IM" />
			<xs:enumeration value="FM" />
			<xs:enumeration value="WGM" />
			<xs:enumeration value="WIM" />
			<xs:enumeration value="WFM" />
			<xs:enumeration value="CM" />
		</xs:restriction>
	</xs:simpleType>


	<xs:complexType name="arbiters-complex">
		<xs:sequence>
			<xs:element name="arbiter" type="arbiter" maxOccurs="unbounded" />
		</xs:sequence>

		<xs:assert test="every $i in 1 to count(arbiter) satisfies (arbiter[$i]/@id = $i)" xerces:message="Arbiters must be serially numbered, beginning with 1.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Schiedsrichter sind aufsteigend durchnummeriert.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="
			every $i in 1 to count(arbiter)-1 satisfies (
				if (arbiter[$i]/name/@type eq 'string') then (
					if (arbiter[$i+1]/name/@type eq 'string') then (
						compare(
							lower-case(arbiter[$i]/name),
							lower-case(arbiter[$i+1]/name)
						) le 0
					) else (
						compare(
							lower-case(arbiter[$i]/name),
							lower-case(concat(arbiter[$i+1]/name/surname, ',', arbiter[$i+1]/name/prename, ',', arbiter[$i+1]/name/academic-title))
						) le 0
					)
				) else (
					if (arbiter[$i+1]/name/@type eq 'string') then (
						compare(
							lower-case(concat(arbiter[$i]/name/surname, ',', arbiter[$i]/name/prename, ',', arbiter[$i]/name/academic-title)),
							lower-case(arbiter[$i+1]/name)
						) le 0
					) else (
						compare(
							lower-case(concat(arbiter[$i]/name/surname, ',', arbiter[$i]/name/prename, ',', arbiter[$i]/name/academic-title)),
							lower-case(concat(arbiter[$i+1]/name/surname, ',', arbiter[$i+1]/name/prename, ',', arbiter[$i+1]/name/academic-title))
						) le 0
					)
				)
			)
		" xerces:message="Arbiters must be sorted by their name.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Schiedsrichter sind aufsteigend sortiert nach Name, d.h. 
					
					Achtung: Die Sortierung erfolgt abhängig von der Collation,
					d.h. standardmäßig 'a' lt 'z' lt 'ä' lt 'ö' lt 'ü'.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>
	</xs:complexType>

	<xs:complexType name="arbiters-string">
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="type" fixed="string" use="required" />
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>

	<xs:complexType name="arbiters-reference-complex">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Referenzierung auf einen Schiedsrichter aus /tournament/information/arbiters
				mittels seiner @id. Optional kann seine Funktion mit @role angegeben werden.
			</xs:documentation>
		</xs:annotation>

		<xs:sequence>
			<xs:element name="arbiter" maxOccurs="unbounded">
				<xs:complexType>
					<xs:attribute name="id" type="xs:positiveInteger" use="required" />

					<xs:attribute name="role" type="arbiter-role" use="optional" />
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>


	<xs:complexType name="time-controls-complex">
		<xs:sequence>
			<xs:element name="period" type="xs:anyType" minOccurs="1" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Erlaubt die Angabe einer Zeitperiode als einen der folgenden Typen:
							* period-complex: Angabe als komplexen Typ (bevorzugt)
							* period-string: Angabe als Freitext (Kompatibilität)
					</xs:documentation>
				</xs:annotation>

				<xs:alternative test="@type and @type eq 'string'" type="period-string" />
				<xs:alternative test="true()" type="period-complex" />
			</xs:element>
		</xs:sequence>

		<xs:assert test="every $i in 1 to count(period) satisfies (period[$i]/@number = $i)" xerces:message="Periods must be serially numbered, beginning with 1.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Perioden müssen aufsteigend nummeriert sein, beginnend mit 1.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="not(period[last()]/moves) or period[last()]/@type eq 'string'" xerces:message="Last period must not contain a 'move' node or must be of @type='string'.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Die letzte Periode darf kein "moves"-Node mehr enthalten
					oder muss vom @type='string' gesetzt haben.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="every $i in 1 to count(period)-1 satisfies (period[$i]/moves or period[$i]/@type eq 'string')" xerces:message="Every period except the last one must contain a 'move' node or must have Attribute @type='string' set.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Alle bisauf die letzte Periode besitzen ein "moves"-Node, außer sie
					sind vom @type='string'.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>
	</xs:complexType>


	<xs:complexType name="period-string">
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="type" fixed="string" use="required" />

				<xs:attribute name="number" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:nonNegativeInteger" />
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>


	<xs:complexType name="period-complex">
		<xs:sequence>
			<xs:element name="moves" minOccurs="0" type="xs:positiveInteger" />
			<xs:element name="time" type="simple-time" />
			<xs:element name="increment" type="simple-time" minOccurs="0" />
		</xs:sequence>

		<xs:attribute name="number" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:nonNegativeInteger" />
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>


	<xs:complexType name="time-controls-string">
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="type" fixed="string" use="required" />
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>


	<xs:simpleType name="arbiter-role">
		<xs:restriction base="xs:string">
			<xs:enumeration value="chief" />
			<xs:enumeration value="deputy" />
		</xs:restriction>
	</xs:simpleType>


	<xs:complexType name="team-captain-is-player">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Mannschaftsführer ist Spieler.
			</xs:documentation>
		</xs:annotation>


		<xs:attribute name="player" type="xs:positiveInteger" use="required" />
	</xs:complexType>

	<xs:complexType name="team-captain">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Mannschaftsführer ist keiner der Spieler, sodass eigene
				Personendaten erfasst werden.
			</xs:documentation>
		</xs:annotation>

		<xs:complexContent>
			<xs:extension base="person">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						[Bisher keine weiteren Informationen]
					</xs:documentation>
				</xs:annotation>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="phone">
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="description" type="xs:string">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Bemerkung/Beschreibung zur Telefonnummer, etwa "dienstlich".
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>


	<xs:simpleType name="mail-entity">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Gültige E-Mail-Adresse (Regex-Pattern).
			</xs:documentation>
		</xs:annotation>

		<xs:restriction base="xs:string">
			<xs:pattern value="([0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\w]*[0-9a-zA-Z]\.)+[a-zA-Z]{2,9})"/>
		</xs:restriction>
	</xs:simpleType>

	<xs:complexType name="mail">
		<xs:simpleContent>
			<xs:extension base="mail-entity">
				<xs:attribute name="description" type="xs:string">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Bemerkung/Beschreibung zur Mail-Adresse.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>


	<xs:complexType name="person-name-complex">
		<xs:sequence>
			<xs:element name="prename" type="xs:string" />

			<xs:element name="surname" type="str_minLength-1" />

			<xs:element name="display-name" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Anzeige-Name, falls abweichend von Vorname/Nachname-Kombination.
					</xs:documentation>
				</xs:annotation>
			</xs:element>

			<xs:element name="academic-title" type="xs:string" minOccurs="0" />
		</xs:sequence>
	</xs:complexType>

	<xs:simpleType name="str_minLength-1">
		<xs:restriction base="xs:string">
			<xs:minLength value="1" />
		</xs:restriction>
	</xs:simpleType>

	<xs:complexType name="person-name-string">
		<xs:simpleContent>
			<xs:extension base="str_minLength-1">
				<xs:attribute name="type" fixed="string" use="required" />
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>


	<xs:complexType name="person">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Personendaten
			</xs:documentation>
		</xs:annotation>

		<xs:sequence>
			<xs:element name="name" type="xs:anyType">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Erlaubt zwei Typen:
							* person-name-complex: Angabe als komplexer Typ
							* (deprecated) person-name-string: Angabe als String
								-- nur wenn type-Attribut gesetzt und gleich "string" ist
					</xs:documentation>
				</xs:annotation>

				<xs:alternative test="@type eq 'string'" type="person-name-string" />
				<xs:alternative test="true()" type="person-name-complex" />
			</xs:element>

			<xs:element name="gender" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Optional: Geschlecht - enum("male", "female")
					</xs:documentation>
				</xs:annotation>

				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="male" />
						<xs:enumeration value="female" />
					</xs:restriction>
				</xs:simpleType>
			</xs:element>

			<xs:choice minOccurs="0">
				<xs:element name="birth">
					<xs:simpleType>
						<xs:restriction base="xs:date">
							<xs:assertion test="$value le current-date()" xerces:message="Birth date must not be in future">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Geburtstag darf nicht in der Zukunft liegen
									</xs:documentation>
								</xs:annotation>
							</xs:assertion>
						</xs:restriction>
					</xs:simpleType>
				</xs:element>

				<xs:element name="birth-year">
					<xs:simpleType>
						<xs:restriction base="xs:gYear">
							<xs:assertion test="xs:int($value) le year-from-date(current-date())" xerces:message="Birth year must not be in future">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Geburtsjahr darf nicht in der Zukunft liegen
									</xs:documentation>
								</xs:annotation>
							</xs:assertion>
						</xs:restriction>
					</xs:simpleType>
				</xs:element>
			</xs:choice>

			<xs:element name="origin" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Freifeld, um die Zuordnung eines Spielers festzuhalten,
						etwa zu seinem Verein, Schule oder Bundesland. Wird häufig
						in Teilnehmer- und Ranglisten verwendet.
					</xs:documentation>
				</xs:annotation>

				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="xs:string">
							<xs:attribute name="type" use="optional" default="">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Optional.
										Semantische Bedeutung der Origin-Zuordnung.
									</xs:documentation>
								</xs:annotation>

								<xs:simpleType>
									<xs:union memberTypes="player-origin-type xs:string" />
								</xs:simpleType>
							</xs:attribute>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>

			<xs:element name="identifiers" type="person-identifiers" minOccurs="0" />

			<xs:element name="contact-information" minOccurs="0">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="address" type="address" minOccurs="0" />
						
						<xs:element name="phone" type="phone" minOccurs="0" maxOccurs="unbounded" />

						<xs:element name="mail" type="mail" minOccurs="0" maxOccurs="unbounded" />
					</xs:sequence>

					<xs:assert test="count(*) ge 0" xerces:message="'contact' node must not be empty.">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Wenn "contact" vorhanden ist, dann darf es nicht leer sein.
							</xs:documentation>
						</xs:annotation>
					</xs:assert>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>


	<xs:complexType name="player">
		<xs:complexContent>
			<xs:extension base="person">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Zusätzliche Informationen für Spieler.
					</xs:documentation>
				</xs:annotation>

				<xs:sequence>
					<xs:element name="title" type="fide-title" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Optional: FIDE-Titel
							</xs:documentation>
						</xs:annotation>
					</xs:element>

					<xs:element name="ratings" minOccurs="0">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="rating" type="rating" minOccurs="1" maxOccurs="unbounded">
									<xs:alternative test="@type='Elo'" type="rating-Elo" />
									<xs:alternative test="@type='DWZ'" type="rating-DWZ" />
								</xs:element>
							</xs:sequence>
						</xs:complexType>

						<xs:unique name="unique-player-rating">
							<xs:selector xpath="rating" />
							<xs:field xpath="@type" />
						</xs:unique>
					</xs:element>
				</xs:sequence>


				<xs:attribute name="id" type="xs:positiveInteger" use="required" />
				<xs:attribute name="inactive" type="xs:boolean" default="false" use="optional" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="arbiter">
		<xs:complexContent>
			<xs:extension base="person">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Zusätzliche Informationen für Schiedsrichter.
					</xs:documentation>
				</xs:annotation>

				<xs:sequence>
					<xs:element name="licence" minOccurs="0" type="arbiter-licence">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Schiedsrichterlizenz
							</xs:documentation>
						</xs:annotation>

						<xs:alternative test="@federation = 'FIDE'" type="arbiter-licence-federation-FIDE" />
						<xs:alternative test="@federation = 'GER' or @federation = 'DE'" type="arbiter-licence-federation-GER" />
					</xs:element>
				</xs:sequence>

				<xs:attribute name="role" type="arbiter-role" />

				<xs:attribute name="id" type="xs:positiveInteger" use="required" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:simpleType name="blank">
		<xs:restriction base="xs:string">
			<xs:enumeration value="" />
		</xs:restriction>
	</xs:simpleType>

	<xs:simpleType name="color">
		<xs:restriction base="xs:string">
			<xs:enumeration value="white" />
			<xs:enumeration value="black" />
		</xs:restriction>
	</xs:simpleType>

	<xs:simpleType name="color-with-blank">
		<xs:union memberTypes="color blank" />
	</xs:simpleType>

	
	<xs:simpleType name="team-win-mode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="more than 50%">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Die Mannschaft, die mehr als 50% der Punkte erzielt, hat die
						Begegnung gewonnen.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>

			<xs:enumeration value="more than opponent">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Die Mannschaft, die mehr Punkte als der Gegner erzielt, hat die
						Begegnung gewonnen.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>


	<xs:complexType name="game-points-individual-result">
		<xs:simpleContent>
			<xs:extension base="xs:decimal">
				<xs:attribute name="attribute" type="result-attribute" use="optional" default="" />

				<xs:attribute name="color" type="color-with-blank" use="optional" default="" />
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>

	<xs:complexType name="game-points-team-result">
		<xs:simpleContent>
			<xs:extension base="xs:decimal">
				<xs:attribute name="attribute" type="result-attribute" use="optional" default="" />
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>


	<xs:complexType name="game-points-individual">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Punkteverteilung für Einzelpaarungen. 
				Standard: Sieg=1, Remis=0.5, Verlust=0.
			</xs:documentation>
		</xs:annotation>

		<xs:sequence>
			<xs:element name="win" type="game-points-individual-result" minOccurs="0" maxOccurs="unbounded" default="1" />
			<xs:element name="draw" type="game-points-individual-result" minOccurs="0" maxOccurs="unbounded" default="0.5" />
			<xs:element name="loss" type="game-points-individual-result" minOccurs="0" maxOccurs="unbounded" default="0" />
		</xs:sequence>

		<xs:assert test="every $a in win/@attribute satisfies (
				if (count(win[@attribute eq $a][@color ne '']) gt 0)
					then (empty(win[@attribute eq $a][@color eq '']) 
									and count(win[@attribute eq $a][@color eq 'white']) eq 1 
									and count(win[@attribute eq $a][@color eq 'black']) eq 1)
					else (true())
			)" xerces:message="The points are given either dependently on the @color or not, but never mixed.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Es kann entweder farbunabhängig (entweder ohne @color oder @color='')
					die Punktzahl angegeben werden oder für jede Farbe einzeln.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>
	</xs:complexType>

	<xs:complexType name="game-points-team">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Punkteverteilung für Mannschaftspaarungen. 
				Standard: Sieg=2, Unentschieden=1, Verlust=0.
				Im Gegensatz zu Einzelpaarungen kann die Punktvergabe bei
				Mannschaftspaarungen nicht farbabhängig sein.
			</xs:documentation>
		</xs:annotation>

		<xs:sequence>
			<xs:element name="win" type="game-points-team-result" minOccurs="0" maxOccurs="unbounded" default="2" />
			<xs:element name="draw" type="game-points-team-result" minOccurs="0" maxOccurs="unbounded" default="1" />
			<xs:element name="loss" type="game-points-team-result" minOccurs="0" maxOccurs="unbounded" default="0" />
		</xs:sequence>

		<xs:attribute name="win-mode" type="team-win-mode" use="optional" default="more than opponent" />
	</xs:complexType>


	<xs:complexType name="single-result-summarization">
		<xs:simpleContent>
			<xs:extension base="xs:nonNegativeInteger">
				<xs:attribute name="attribute" type="result-attribute" use="optional" default="" />
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>


	<xs:complexType name="board-single-player">
		<xs:attribute name="player" type="xs:positiveInteger" />
	</xs:complexType>

	<xs:complexType name="_t_board-single-player">
		<xs:complexContent>
			<xs:extension base="board-single-player">
				<xs:attribute name="team" type="xs:positiveInteger" use="required">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Mannschaft, der der Spieler angehört.
							Notwendig, da ein (Ersatz-) Spieler mitunter auch in zwei
							Mannschaften gemeldet sein kann.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>

				<xs:attribute name="seeded-too-low" type="xs:boolean" use="optional" default="false">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Flag, dass ein Spieler zu tief eingesetzt wurde, d.h.
							in der Mannschaftsbegegnung vor ihm ein Spieler mit höherer
							@position angetreten ist.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:simpleType name="board-result">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Resultat einer Einzelpartie (eines Spielers).
			</xs:documentation>
		</xs:annotation>

		<xs:restriction base="xs:decimal">
			<xs:enumeration value="0" />
			<xs:enumeration value="0.5" />
			<xs:enumeration value="1" />
		</xs:restriction>
	</xs:simpleType>

	<xs:simpleType name="result-attribute">
		<xs:restriction base="xs:string">
			<xs:enumeration value="by-default" />

			<xs:enumeration value="adjourned" />

			<xs:enumeration value="" />
		</xs:restriction>
	</xs:simpleType>

	<xs:complexType name="result-single">
		<xs:sequence>
			<xs:element name="white" type="board-result" />
			<xs:element name="black" type="board-result" />
		</xs:sequence>

		<xs:attribute name="attribute" type="result-attribute" use="optional" />

		<xs:attribute name="overruled" type="xs:boolean" use="optional" default="false">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Nicht mehr gültiges Resultat, da von Instanz (Turnierleitung, 
					Staffelleitung, Schiedsgericht, ...) aufgehoben.
					Im Falle einer solchen Entscheidung ist das tatsächlich
					gespielte Ergebnis mit diesem Attribut versehen.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>

		<xs:attribute name="special" type="xs:boolean" use="optional" default="false">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Zur Eingabe von Sonderergebnissen (Punktsumme ungleich 1)
					kann @special='true' gesetzt werden.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>

		<xs:assert test="if (not(xs:boolean(@special))) then (white + black eq 1) else true()" xerces:message="Points sum equals not 1. Set @special='true' for special results.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Prüft im Falle von @special='false' (d.h. es wurde nicht
					explizit ein Sonderergebnis mit Punktsumme ungleich 1
					angegeben), ob die Punktsumme 1 beträgt.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>
	</xs:complexType>


	<xs:simpleType name="board-attribute">
		<xs:restriction base="xs:string">
			<xs:enumeration value="" />

			<xs:enumeration value="bye">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Spielfrei, Freilos.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>


	<xs:complexType name="_interface-board-general">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Oberklasse für board-bye und board, sollte nicht
				direkt benutzt werden.
			</xs:documentation>
		</xs:annotation>

		<xs:attribute name="attribute" type="board-attribute" use="optional" default="" />
		<xs:attribute name="number" type="xs:positiveInteger" use="required" />
	</xs:complexType>

	<xs:complexType name="board-bye">
		<xs:complexContent>
			<xs:extension base="_interface-board-general">
				<xs:sequence>
					<xs:element name="player">
						<xs:complexType>
							<xs:attribute name="id" type="xs:positiveInteger" />
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="board_single">
		<xs:complexContent>
			<xs:extension base="_interface-board-general">
				<xs:choice>
					<xs:sequence>
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Angabe eines Ergebnisses eines Einzelspiels unter Angabe
								von Weiß, Schwarz und ggf. Ergebnis. Für alle Turniere, bei
								denen nur eine Partie pro Runde gespielt wird.
							</xs:documentation>
						</xs:annotation>

						<xs:element name="white" type="board-single-player" />

						<xs:element name="black" type="board-single-player" />

						<xs:element name="result" type="result-single" minOccurs="0" maxOccurs="2">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Das Partieergebnis kann bis zu zweimal erfasst werden:
										* kein "result"-Element:
											Ergebnis liegt noch nicht vor.
										* ein "result"-Element:
											Ergebnis gesetzt.
										* zwei "result"-Elemente:
											Ergebnis wurde durch Instanz (Turnierleitung, ...)
											korrigiert, genau ein "result"-Element besitzt also
											das Attribute @attribute="overruled".
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>

					<xs:sequence>
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Angabe einer konkreten Paarung zweier Spieler bei 
								einem Turnier, bei dem mehrere Partien pro Runde
								gespielt werden.
								Es kann kein @swapped-Attribut für das Board gesetzt werden,
								stattdessen müssten alle Einzelpartien auf mit dem
								@swapped-Attribut versehen werden.
							</xs:documentation>
						</xs:annotation>

						<xs:element name="player" minOccurs="2" maxOccurs="2">
							<xs:complexType>
								<xs:attribute name="position" use="required">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Angabe, ob erst- oder zweitgenannt.
										</xs:documentation>
									</xs:annotation>

									<xs:simpleType>
										<xs:restriction base="xs:positiveInteger">
											<xs:enumeration value="1" />
											<xs:enumeration value="2" />
										</xs:restriction>
									</xs:simpleType>
								</xs:attribute>

								<xs:attribute name="id" type="xs:positiveInteger" use="required" />
							</xs:complexType>
						</xs:element>

						<xs:choice>
							<xs:element name="games">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Angabe der Einzelspiele.
									</xs:documentation>
								</xs:annotation>

								<xs:complexType>
									<xs:sequence>
										<xs:element name="game" minOccurs="2" maxOccurs="unbounded">
											<xs:complexType>
												<xs:sequence>
													<xs:element name="white" type="board-single-player" />

													<xs:element name="black" type="board-single-player" />

													<xs:element name="result" type="result-single" minOccurs="0" maxOccurs="2" />
												</xs:sequence>

												<xs:attribute name="number" type="xs:positiveInteger" use="required" />

												<xs:attribute name="swapped" type="xs:boolean" use="optional" default="false">
													<xs:annotation>
														<xs:documentation xml:lang="DE">
															Flag, ob die Partie mit vertauschen Farben aufgenommen wurde. Gespeichert
															wird immer die ursprünglich ausgeloste Farbverteilung, sodass über 
															@swapped='true' die Vertauschung kenntlich gemacht werden kann.
														</xs:documentation>
													</xs:annotation>
												</xs:attribute>
											</xs:complexType>

											<xs:unique name="multiple-games_game_unique-opponent">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Weiß und Schwarz müssen eine unterschiedliche Spieler-ID
														@player besitzen.
													</xs:documentation>
												</xs:annotation>

												<xs:selector xpath="white | black" />
												<xs:field xpath="@player" />
											</xs:unique>
										</xs:element>
									</xs:sequence>

									<xs:assert test="every $i in 1 to count(game) satisfies (game[$i]/@number eq $i)" xerces:message="The games must be serially numbered by their @number attribute, beginning with 1.">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Die Spiele müssen aufsteigend durchnummeriert sein, 
												beginnend mit 1.
											</xs:documentation>
										</xs:annotation>
									</xs:assert>
								</xs:complexType>
							</xs:element>

							<xs:element name="results">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Auflistung der Resultate aller (bisher absolvierten) 
										Einzelspiele.
									</xs:documentation>
								</xs:annotation>

								<xs:complexType>
									<xs:sequence>
										<xs:element name="player" minOccurs="2" maxOccurs="2">
											<xs:complexType>
												<xs:sequence>
													<xs:element name="wins" type="single-result-summarization" minOccurs="0" maxOccurs="unbounded" />
													<xs:element name="draws" type="single-result-summarization" minOccurs="0" maxOccurs="unbounded" />
													<xs:element name="losses" type="single-result-summarization" minOccurs="0" maxOccurs="unbounded" />
												</xs:sequence>

												<xs:attribute name="position" use="required">
													<xs:simpleType>
														<xs:restriction base="xs:positiveInteger">
															<xs:enumeration value="1" />
															<xs:enumeration value="2" />
														</xs:restriction>
													</xs:simpleType>
												</xs:attribute>
											</xs:complexType>


											<xs:unique name="_s_unique-result-entry_wins">
												<xs:selector xpath="wins" />
												<xs:field xpath="@attribute" />
											</xs:unique>
											<xs:unique name="_s_unique-result-entry_draws">
												<xs:selector xpath="draws" />
												<xs:field xpath="@attribute" />
											</xs:unique>
											<xs:unique name="_s_unique-result-entry_losses">
												<xs:selector xpath="losses" />
												<xs:field xpath="@attribute" />
											</xs:unique>
										</xs:element>
									</xs:sequence>


									<xs:attribute name="overruled" type="xs:boolean" use="optional" default="false">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Nicht mehr gültiges Resultat, da von Instanz (Turnierleitung, 
												Staffelleitung, Schiedsgericht, ...) aufgehoben.
												Im Falle einer solchen Entscheidung ist das tatsächlich
												gespielte Ergebnis mit diesem Attribut versehen.
											</xs:documentation>
										</xs:annotation>
									</xs:attribute>


									<xs:assert test="every $i in 1 to count(player) satisfies (player[$i]/@position and player[$i]/@position eq $i)" xerces:message="The players @position must be serially numbered, beginning with 1.">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Die Spieler sind aufsteigend durchnummeriert, beginnend
												mit 1.
											</xs:documentation>
										</xs:annotation>
									</xs:assert>

									<xs:assert test="sum(player[1]/*) eq sum(player[2]/*)" xerces:message="The number of saved results of both players must be equal.">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Die Anzahl der hinterlegten Ergebnisse ist für beide Spieler
												gleich.
											</xs:documentation>
										</xs:annotation>
									</xs:assert>
								</xs:complexType>
							</xs:element>
						</xs:choice>
					</xs:sequence>
				</xs:choice>

				<xs:attribute name="swapped" type="xs:boolean" use="optional" default="false">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Flag, ob die Partie mit vertauschen Farben aufgenommen wurde. Gespeichert
							wird immer die ursprünglich ausgeloste Farbverteilung, sodass über 
							@swapped='true' die Vertauschung kenntlich gemacht werden kann.
							Werden mehrere Partien pro Runde gespielt, darf @swapped für das Board
							nicht auf 'true' gesetzt sein. Wurden alle Farben vertauscht, ist dies an
							jedem einzelnen Spiel in 'games' deutlich zu machen.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>


				<xs:assert test="if (count(result) ge 1) then (count(result[not(xs:boolean(@overruled))]) eq 1) else true()" xerces:message="If multiple results are given, only one should have the @overruled='false' set.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Falls mehrere Ergebnisse gespeichert sind, darf nur genau
							eines gültig sein, d.h. @overruled='false' sein.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="every $i in 1 to count(player) satisfies (player[$i]/@position and player[$i]/@position eq $i)" xerces:message="The player/@position must be serially numbered, beginning with 1.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Für jeden Spieler muss das @position Attribut gesetzt und
							aufsteigend durchnummert sein.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="xs:string(@swapped) eq 'false' or count(games) eq 0" xerces:message="The @swapped attribute of boards must not be set to 'true' in tournaments with multiple games per round. Please mark instead every single game as @swapped.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Das @swapped Attribut darf für ein Board nur auf 'true' gesetzt
							sein, wenn nur eine Partie pro Runde gespielt wird.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="every $id in (games/game/(white | black)/@player) satisfies ($id eq player[1]/@id or $id eq player[2]/@id)" xerces:message="The players referenced in each game must be the same as for this board.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Die in games/game/(white|black)/@player genannten Spieler-IDs
							müssen mit denen in player/@id übereinstimmen.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="if (count(results) ge 1) then (count(results[not(xs:boolean(@overruled))]) eq 1) else true()" xerces:message="There must be exactly one result with @overrule='false'.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Falls die Ergebnisse über die results-Methode erfasst werden, darf nur
							genau eines gültig sein, d.h. @overrule='false' sein.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="_t_board">
		<xs:complexContent>
			<xs:extension base="_interface-board-general">
				<xs:choice>
					<xs:sequence>
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Angabe eines Ergebnisses eines Einzelspiels unter Angabe
								von Weiß, Schwarz und ggf. Ergebnis. Für alle Turniere, bei
								denen nur eine Partie pro Runde gespielt wird.
							</xs:documentation>
						</xs:annotation>

						<xs:element name="white" type="_t_board-single-player" />

						<xs:element name="black" type="_t_board-single-player" />

						<xs:element name="result" type="result-single" minOccurs="0" maxOccurs="2">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Das Partieergebnis kann bis zu zweimal erfasst werden:
										* kein "result"-Element:
											Ergebnis liegt noch nicht vor.
										* ein "result"-Element:
											Ergebnis gesetzt.
										* zwei "result"-Elemente:
											Ergebnis wurde durch Instanz (Turnierleitung, ...)
											korrigiert, genau ein "result"-Element besitzt also
											das Attribute @attribute="overruled".
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>

					<xs:sequence>
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Angabe einer konkreten Paarung zweier Spieler bei 
								einem Turnier, bei dem mehrere Partien pro Runde
								gespielt werden.
								Es kann kein @swapped-Attribut für das Board gesetzt werden,
								stattdessen müssten alle Einzelpartien auf mit dem
								@swapped-Attribut versehen werden.
							</xs:documentation>
						</xs:annotation>

						<xs:element name="player" minOccurs="2" maxOccurs="2">
							<xs:complexType>
								<xs:attribute name="team" type="xs:positiveInteger" use="required">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Angabe, welchem Team der Spieler angehört.
										</xs:documentation>
									</xs:annotation>
								</xs:attribute>

								<xs:attribute name="position" use="required">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Angabe, ob erst- oder zweitgenannt.
										</xs:documentation>
									</xs:annotation>

									<xs:simpleType>
										<xs:restriction base="xs:positiveInteger">
											<xs:enumeration value="1" />
											<xs:enumeration value="2" />
										</xs:restriction>
									</xs:simpleType>
								</xs:attribute>

								<xs:attribute name="id" type="xs:positiveInteger" use="required" />
							</xs:complexType>
						</xs:element>

						<xs:choice>
							<xs:element name="games">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Angabe der Einzelspiele.
									</xs:documentation>
								</xs:annotation>

								<xs:complexType>
									<xs:sequence>
										<xs:element name="game" minOccurs="2" maxOccurs="unbounded">
											<xs:complexType>
												<xs:sequence>
													<xs:element name="white" type="board-single-player" />

													<xs:element name="black" type="board-single-player" />

													<xs:element name="result" type="result-single" minOccurs="0" maxOccurs="2" />
												</xs:sequence>

												<xs:attribute name="number" type="xs:positiveInteger" use="required" />

												<xs:attribute name="swapped" type="xs:boolean" use="optional" default="false">
													<xs:annotation>
														<xs:documentation xml:lang="DE">
															Flag, ob die Partie mit vertauschen Farben aufgenommen wurde. Gespeichert
															wird immer die ursprünglich ausgeloste Farbverteilung, sodass über 
															@swapped='true' die Vertauschung kenntlich gemacht werden kann.
														</xs:documentation>
													</xs:annotation>
												</xs:attribute>
											</xs:complexType>

											<xs:unique name="_t_multiple-games_game_unique-opponent">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Weiß und Schwarz müssen eine unterschiedliche Spieler-ID
														@player besitzen.
													</xs:documentation>
												</xs:annotation>

												<xs:selector xpath="white | black" />
												<xs:field xpath="@player" />
											</xs:unique>
										</xs:element>
									</xs:sequence>

									<xs:assert test="every $i in 1 to count(game) satisfies (game[$i]/@number eq $i)" xerces:message="The games must be serially numbered by their @number attribute, beginning with 1.">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Die Spiele müssen aufsteigend durchnummeriert sein, 
												beginnend mit 1.
											</xs:documentation>
										</xs:annotation>
									</xs:assert>
								</xs:complexType>
							</xs:element>

							<xs:element name="results">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Auflistung der Resultate aller (bisher absolvierten) 
										Einzelspiele.
									</xs:documentation>
								</xs:annotation>

								<xs:complexType>
									<xs:sequence>
										<xs:element name="player" minOccurs="2" maxOccurs="2">
											<xs:complexType>
												<xs:sequence>
													<xs:element name="wins" type="single-result-summarization" minOccurs="0" maxOccurs="unbounded" />
													<xs:element name="draws" type="single-result-summarization" minOccurs="0" maxOccurs="unbounded" />
													<xs:element name="losses" type="single-result-summarization" minOccurs="0" maxOccurs="unbounded" />
												</xs:sequence>

												<xs:attribute name="position" use="required">
													<xs:simpleType>
														<xs:restriction base="xs:positiveInteger">
															<xs:enumeration value="1" />
															<xs:enumeration value="2" />
														</xs:restriction>
													</xs:simpleType>
												</xs:attribute>
											</xs:complexType>


											<xs:unique name="_t_unique-result-entry_wins">
												<xs:selector xpath="wins" />
												<xs:field xpath="@attribute" />
											</xs:unique>
											<xs:unique name="_t_unique-result-entry_draws">
												<xs:selector xpath="draws" />
												<xs:field xpath="@attribute" />
											</xs:unique>
											<xs:unique name="_t_unique-result-entry_losses">
												<xs:selector xpath="losses" />
												<xs:field xpath="@attribute" />
											</xs:unique>
										</xs:element>
									</xs:sequence>


									<xs:attribute name="overruled" type="xs:boolean" use="optional" default="false">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Nicht mehr gültiges Resultat, da von Instanz (Turnierleitung, 
												Staffelleitung, Schiedsgericht, ...) aufgehoben.
												Im Falle einer solchen Entscheidung ist das tatsächlich
												gespielte Ergebnis mit diesem Attribut versehen.
											</xs:documentation>
										</xs:annotation>
									</xs:attribute>


									<xs:assert test="every $i in 1 to count(player) satisfies (player[$i]/@position and player[$i]/@position eq $i)" xerces:message="The players @position must be serially numbered, beginning with 1.">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Die Spieler sind aufsteigend durchnummeriert, beginnend
												mit 1.
											</xs:documentation>
										</xs:annotation>
									</xs:assert>

									<xs:assert test="sum(player[1]/*) eq sum(player[2]/*)" xerces:message="The number of saved results of both players must be equal.">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Die Anzahl der hinterlegten Ergebnisse ist für beide Spieler
												gleich.
											</xs:documentation>
										</xs:annotation>
									</xs:assert>
								</xs:complexType>
							</xs:element>
						</xs:choice>
					</xs:sequence>
				</xs:choice>


				<xs:attribute name="swapped" type="xs:boolean" use="optional" default="false">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Flag, ob die Partie mit vertauschen Farben aufgenommen wurde. Gespeichert
							wird immer die ursprünglich ausgeloste Farbverteilung, sodass über 
							@swapped='true' die Vertauschung kenntlich gemacht werden kann.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>


				<xs:assert test="if (count(result) ge 1) then (count(result[not(xs:boolean(@overruled))]) eq 1) else true()" xerces:message="If multiple results are given, only one should have the @overruled='false' set.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Falls mehrere Ergebnisse gespeichert sind, darf nur genau
							eines gültig sein, d.h. @overruled='false' sein.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="white/@team ne black/@team and player[1]/@team ne player[2]/@team" xerces:message="Players must be of different teams.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Die Spieler müssen aus verschiedenen Mannschaften sein.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="every $i in 1 to count(player) satisfies (player[$i]/@position and player[$i]/@position eq $i)" xerces:message="The player/@position must be serially numbered, beginning with 1.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Für jeden Spieler muss das @position Attribut gesetzt und
							aufsteigend durchnummert sein.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="xs:string(@swapped) eq 'false' or count(games) eq 0" xerces:message="The @swapped attribute of boards must not be set to 'true' in tournaments with multiple games per round. Please mark instead every single game as @swapped.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Das @swapped Attribut darf für ein Board nur auf 'true' gesetzt
							sein, wenn nur eine Partie pro Runde gespielt wird.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="every $id in (games/game/(white | black)/@player) satisfies ($id eq player[1]/@id or $id eq player[2]/@id)" xerces:message="The players referenced in each game must be the same as for this board.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Die in games/game/(white|black)/@player genannten Spieler-IDs
							müssen mit denen in player/@id übereinstimmen.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="if (count(results) ge 1) then (count(results[not(xs:boolean(@overruled))]) eq 1) else true()" xerces:message="There must be exactly one result with @overrule='false'.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Falls die Ergebnisse über die results-Methode erfasst werden, darf nur
							genau eines gültig sein, d.h. @overrule='false' sein.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:simpleType name="ranking-entity">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Feinwertungen zur Ermittlung des Rankings
			</xs:documentation>
		</xs:annotation>

		<xs:list itemType="xs:decimal" />
	</xs:simpleType>

	<xs:complexType name="ranking-row">
		<xs:simpleContent>
			<xs:extension base="ranking-entity">
				<xs:attribute name="position" type="xs:positiveInteger" use="required" />

				<xs:attribute name="id" type="xs:positiveInteger" use="required" />
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>


	<xs:complexType name="ranking-round" abstract="true">
		<xs:attribute name="number" type="xs:positiveInteger" use="required" />

		<xs:attribute name="attribute" use="optional" default="">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="" />

					<xs:enumeration value="interim">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Rangliste vorläufig.
							</xs:documentation>
						</xs:annotation>
					</xs:enumeration>

					<xs:enumeration value="live">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Live-Tabelle, resultierend aus Live-Ergebnissen.
							</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>


	<xs:complexType name="ranking-criterion">
		<xs:attribute name="number" type="xs:positiveInteger" use="required">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Reihenfolge, in der die Wertungen angewandt werden.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>


	<xs:complexType name="initial-ranking-criterion">
		<xs:complexContent>
			<xs:extension base="ranking-criterion">
				<xs:attribute name="type">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="Rating">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Wertungszahl.
										Es können auch mehrere Rating-Systeme angegeben werden, wenn
										zusätzlich das @get="{min,max}" Attribut angegeben wird. In 
										diesem Fall wird die höchste bzw. niedrigste dieser Zahlen
										genutzt.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="FIDE-Title">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Sortierung nach FIDE-Titeln. Reihenfolge:
										GM - IM - WGM - FM - WIM - CM - WFM - WCM - ohne
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Name">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Alphabetische Sortierung nach "Name,Vorname".
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Random">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Auslosen.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Custom">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Eigene Wertung.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="initial-ranking-criterion-Rating">
		<xs:complexContent>
			<xs:extension base="initial-ranking-criterion">
				<xs:choice>
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Es kann entweder genau ein Rating-Type angegeben werden oder
							mehrere, von denen der Minimal- oder Maximalwert oder der erste
							Wert ungleich null genutzt wird.
						</xs:documentation>
					</xs:annotation>

					<xs:element name="rating-type">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Angabe genau eines Rating-Types.
							</xs:documentation>
						</xs:annotation>
						
						<xs:complexType>
							<xs:simpleContent>
								<xs:extension base="rating-system">
									<xs:attribute name="on-empty" type="xs:integer">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Angabe, welcher Wert angenommen werden soll, wenn der
												Spieler die angegebene Wertungszahl nicht besitzt.
											</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:extension>
							</xs:simpleContent>
						</xs:complexType>
					</xs:element>

					<xs:element name="rating-types" type="ranking-criterion-Rating-multiples">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Angabe mehrerer Rating-Types, deren Minimal- oder Maximalwert
								oder erster Wert ungleich null genutzt wird.
							</xs:documentation>
						</xs:annotation>

						<xs:alternative test="@get eq 'order'" type="ranking-criterion-Rating-multiples_ordered">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Angabe der Rating-Types in einer Reihenfolge, deren erster
									Wert ungleich null angenommen wird.
								</xs:documentation>
							</xs:annotation>
						</xs:alternative>

						<xs:alternative test="true()" type="ranking-criterion-Rating-multiples_minmax">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Angabe der Rating-Types ohne Reihenfolge, Minimal-
									oder Maximalwert wird angenommen.
								</xs:documentation>
							</xs:annotation>
						</xs:alternative>

						<xs:unique name="initial-ranking-criterion-Rating_unique-rating-types">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Die angegebenen Rating-Types dürfen nur einfach auftreten.
								</xs:documentation>
							</xs:annotation>

							<xs:selector xpath="rating-type" />
							<xs:field xpath="." />
						</xs:unique>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="ranking-criterion-Rating-multiples">
		<xs:attribute name="get" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="min" />
					<xs:enumeration value="max" />
					<xs:enumeration value="order">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Die Rating-Systeme werden in definierter Reihenfolge
								übergeben und der erste Wert ungleich null wird genutzt.
							</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="ranking-criterion-Rating-multiples_minmax">
		<xs:complexContent>
			<xs:extension base="ranking-criterion-Rating-multiples">
				<xs:sequence>
					<xs:element name="rating-type" minOccurs="2" maxOccurs="unbounded">
						<xs:complexType>
							<xs:simpleContent>
								<xs:extension base="rating-system">
									<xs:attribute name="on-empty" type="xs:integer">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Angabe, welcher Wert angenommen werden soll, wenn der
												Spieler die angegebene Wertungszahl nicht besitzt.
											</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:extension>
							</xs:simpleContent>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="ranking-criterion-Rating-multiples_ordered">
		<xs:complexContent>
			<xs:extension base="ranking-criterion-Rating-multiples">
				<xs:sequence>
					<xs:element name="rating-type" minOccurs="1" maxOccurs="unbounded">
						<xs:complexType>
							<xs:simpleContent>
								<xs:extension base="rating-system">
									<xs:attribute name="number" type="xs:positiveInteger" use="required" />

									<xs:attribute name="on-empty" type="xs:integer">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Angabe, welcher Wert angenommen werden soll, wenn der
												Spieler keine der angegebenen Wertungszahlen besitzt.
												Einzig erlaubt für das rating-system mit der höchsten number.
											</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:extension>
							</xs:simpleContent>
						</xs:complexType>
					</xs:element>
				</xs:sequence>

				<xs:assert test="every $i in 1 to count(rating-type) satisfies (rating-type[$i]/@number eq $i)" xerces:message="Rating-types must be serially numbered, beginning with 1.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Die Rating-Typen müssen über ihr @number Attribut
							durchnummeriert sein, beginnend bei 1.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="every $i in 1 to count(rating-type)-1 satisfies (count(rating-type[$i]/@on-empty) eq 0)" xerces:message="rating-type/@on-empty might only be specified for the last one.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Das @on-empty Attribut darf nur für den letzten rating-type angegeben werden.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="initial-ranking-criterion-Custom">
		<xs:complexContent>
			<xs:extension base="initial-ranking-criterion">
				<xs:sequence>
					<xs:element name="name">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Name der selbstdefinierten Wertung.
								Pflichtangabe.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:simpleContent>
								<xs:extension base="xs:string">
									<xs:attribute name="abbreviation" type="xs:string" use="optional">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Abkürzung der Wertung, etwa zur Angabe in Tabellen.
												Optional.
											</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:extension>
							</xs:simpleContent>
						</xs:complexType>
					</xs:element>

					<xs:element name="type" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Angabe, was für Werte angenommen werden können: "numeric", "alphanumeric", "alphabetic".
								Optional.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:simpleContent>
								<xs:extension base="criterion-Custom-type-values">
									<xs:attribute name="order" type="order" use="optional">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Angabe der Reihenfolge der geführten Wertungen: 
												"ascending" bedeutet, dass Spieler mit kleineren Werten höher
												platziert sind als solche mit höheren; "descending" umgekehrt.
											</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:extension>
							</xs:simpleContent>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:simpleType name="criterion-Custom-type-values">
		<xs:restriction base="xs:string">
			<xs:enumeration value="numeric" />
			<xs:enumeration value="alphanumeric" />
			<xs:enumeration value="alphabetical" />
		</xs:restriction>
	</xs:simpleType>

	<xs:simpleType name="order">
		<xs:restriction base="xs:string">
			<xs:enumeration value="ascending" />
			<xs:enumeration value="descending" />
		</xs:restriction>
	</xs:simpleType>


	<xs:complexType name="_t_initial-ranking-criterion">
		<xs:complexContent>
			<xs:extension base="ranking-criterion">
				<xs:attribute name="type">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="Rating">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Durchschnittliche Wertungszahl.
										Es können auch mehrere Rating-Systeme angegeben werden.
										Über das players Element kann die Anzahl der Spieler benannt werden,
										die zur Durchschnittsbildung herangezogen werden. Sind die Spieler unsortiert
										(etwa bei Pokalturnieren), d.h. die Spieler in /tournament/teams/team/player verfügen
										alle über kein @number-Attribut, so werden die besten @players Spieler zur
										Durchschnittsbildung herangezogen.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Name">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Alphabetische Sortierung nach Teamname.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Random">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Auslosen.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Custom">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Eigene Wertung.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="_t_initial-ranking-criterion-Rating">
		<xs:complexContent>
			<xs:extension base="_t_initial-ranking-criterion">
				<xs:sequence>
					<xs:element name="players" type="_t_taken-players-for-ranking-criterion">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Anzahl der Spieler, die in die Durchschnittsberechnung einfließen sollen.
								Entweder ein xs:positiveInteger-Wert oder "all" (Standard).
								Pflichtangabe.
							</xs:documentation>
						</xs:annotation>
					</xs:element>

					<xs:choice>
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Es kann entweder genau ein Rating-Type angegeben werden oder
								mehrere, von denen der Minimal- oder Maximalwert genutzt wird.
							</xs:documentation>
						</xs:annotation>

						<xs:element name="rating-type" type="rating-system-ranking">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Angabe genau eines Rating-Types.
								</xs:documentation>
							</xs:annotation>
						</xs:element>

						<xs:element name="rating-types" type="_t_ranking-criterion-Rating-multiples">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Angabe mehrerer Rating-Types, deren Minimal- oder Maximalwert
									oder erster Wert ungleich null genutzt wird.
								</xs:documentation>
							</xs:annotation>

							<xs:alternative test="@get eq 'order'" type="_t_ranking-criterion-Rating-multiples_ordered">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Angabe der Rating-Types in einer Reihenfolge, deren erster
										Wert ungleich null angenommen wird.
									</xs:documentation>
								</xs:annotation>
							</xs:alternative>

							<xs:alternative test="true()" type="_t_ranking-criterion-Rating-multiples_minmax">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Angabe der Rating-Types ohne Reihenfolge, Minimal-
										oder Maximalwert wird angenommen.
									</xs:documentation>
								</xs:annotation>
							</xs:alternative>

							<xs:unique name="_t_initial-ranking-criterion-Rating_unique-rating-types">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Die angegebenen Rating-Types dürfen nur einfach auftreten.
									</xs:documentation>
								</xs:annotation>

								<xs:selector xpath="rating-type" />
								<xs:field xpath="." />
							</xs:unique>
						</xs:element>
					</xs:choice>
				</xs:sequence>

				<xs:assert test="xs:string(players) ne 'all' or players/@order eq 'position'" xerces:message="If the Rating criterion should be calculated for all team members, i.e. criterion/players = 'all', their order players/@order must either not be set or set to 'position'.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Falls das players-Element auf 'all' gesetzt ist, darf players/@order
							nur 'position' sein, was dem Defaultwert entspricht.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="_t_ranking-criterion-Rating-multiples">
		<xs:attribute name="get" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="min" />
					<xs:enumeration value="max" />
					<xs:enumeration value="order">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Die Rating-Systeme werden in definierter Reihenfolge
								übergeben und der erste Wert ungleich null wird genutzt.
							</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="_t_ranking-criterion-Rating-multiples_minmax">
		<xs:complexContent>
			<xs:extension base="_t_ranking-criterion-Rating-multiples">
				<xs:sequence>
					<xs:element name="rating-type" type="rating-system-ranking" minOccurs="2" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Ist bei einem Rating-Type @on-empty={ignore,next} gesetzt, so
								wird diese Direktive umgesetzt, sobald der Spieler für diesen
								Typ keine Wertungszahl besitzt. Es ist möglich, bei einigen Typen
								{next,ignore}, und bei anderen Zahlenwerte zu setzen.
							</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="_t_ranking-criterion-Rating-multiples_ordered">
		<xs:complexContent>
			<xs:extension base="_t_ranking-criterion-Rating-multiples">
				<xs:sequence>
					<xs:element name="rating-type" minOccurs="1" maxOccurs="unbounded">
						<xs:complexType>
							<xs:simpleContent>
								<xs:extension base="rating-system">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Extension zu "rating-system" statt "rating-system-ranking", da
											das @on-empty Attribut bei @get='ordered' keinen Sinn macht.
										</xs:documentation>
									</xs:annotation>

									<xs:attribute name="number" type="xs:positiveInteger" use="required" />
								</xs:extension>
							</xs:simpleContent>
						</xs:complexType>
					</xs:element>
				</xs:sequence>

				<xs:assert test="every $i in 1 to count(rating-type) satisfies (rating-type[$i]/@number eq $i)" xerces:message="Rating-types must be serially numbered, beginning with 1.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Die Rating-Typen müssen über ihr @number Attribut
							durchnummeriert sein, beginnend bei 1.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="_t_initial-ranking-criterion-Custom">
		<xs:complexContent>
			<xs:extension base="_t_initial-ranking-criterion">
				<xs:sequence>
					<xs:element name="name">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Name der selbstdefinierten Wertung.
								Pflichtangabe.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:simpleContent>
								<xs:extension base="xs:string">
									<xs:attribute name="abbreviation" type="xs:string" use="optional">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Abkürzung der Feinwertung, etwa zur Angabe in Tabellen.
												Optional.
											</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:extension>
							</xs:simpleContent>
						</xs:complexType>
					</xs:element>

					<xs:element name="type" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Angabe, was für Werte angenommen werden können: "numeric", "alphanumeric", "alphabetic".
								Optional.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:simpleContent>
								<xs:extension base="criterion-Custom-type-values">
									<xs:attribute name="order" type="order" use="optional">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Angabe der Reihenfolge der geführten Wertungen: 
												"ascending" bedeutet, dass Spieler mit kleineren Werten höher
												platziert sind als solche mit höheren; "descending" umgekehrt.
											</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:extension>
							</xs:simpleContent>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:simpleType name="_t_taken-players-for-ranking-criterion_value">
		<xs:union memberTypes="xs:positiveInteger str_all" />
	</xs:simpleType>

	<xs:complexType name="_t_taken-players-for-ranking-criterion">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Anzahl der Spieler, die in für ein zuvor angegebenes Ranglisten-
				kriterium in die Berechnung einfließen sollen.
				Entweder ein xs:positiveInteger-Wert oder "all" (Standard).
			</xs:documentation>
		</xs:annotation>

		<xs:simpleContent>
			<xs:extension base="_t_taken-players-for-ranking-criterion_value">
				<xs:attribute name="order" use="optional" default="position">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="position">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Nach Position in der Mannschaft.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="ascending">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Aufsteigend nach ihren Werten bei diesem Kriterium.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="descending">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Absteigend nach ihren Werten bei diesem Kriterium.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>


				<xs:attribute name="on-empty" use="optional" default="ignore">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="ignore">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Verfügt der in der Durchschnittswertung betrachtete Spieler über keine Wertungszahl in diesem Rating-System, so wird er einfach ignoriert und der Durchschnitt dementsprechend über weniger Spieler gebildet.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="next">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Verfügt der in der Durchschnittswertung betrachtete Spieler über keine Wertungszahl in diesem Rating-System, so wird statt seiner ein weiterer Spieler dieser Mannschaft zur Durchschnittsbildung herangezogen.

										Beispiel: Die Spieler 1 bis 3 und 5 bis 8 verfügen über eine DWZ, der Durchschnitt soll über 4 Spieler erfasst werden (über @players Direktive im criterion-Node). Ist @on-empty="next" gesetzt, fließt zusätzlich Spieler 5 in die Durchschnittsberechnung ein, da Spieler 4 über keine Wertungszahl verfügt.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>


	<xs:simpleType name="str_all">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				xs:string, das nur "all" zulässt.
			</xs:documentation>
		</xs:annotation>

		<xs:restriction base="xs:string">
			<xs:enumeration value="all" />
		</xs:restriction>
	</xs:simpleType>


	<xs:simpleType name="str_unbounded">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				xs:string, das nur "unbounded" zulässt.
			</xs:documentation>
		</xs:annotation>

		<xs:restriction base="xs:string">
			<xs:enumeration value="unbounded" />
		</xs:restriction>
	</xs:simpleType>


	<xs:complexType name="rounds-ranking-criterion">
		<xs:complexContent>
			<xs:extension base="ranking-criterion">
				<xs:attribute name="type">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="Points">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Punkte.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Buchholz">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Buchholz-Wertung und verfeinerte Buchholz-Wertung.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Buchholz-Sum">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Buchholz-Summe.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Progressive-Score">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Fortschritts-/Summenwertung.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Progressive-Opponent-Score">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Fortschritts-Gegner-Wertung. Summiert die Punkte
										der Gegner von jeder Runde.
										Vgl. http://en.wikipedia.org/wiki/Tie-breaking_in_Swiss-system_tournaments#Cumulative_opponent.27s_score
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Sonneborn-Berger">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Sonneborn-Berger-Wertung.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Wins">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Siegwertung, Anzahl der Siege.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Black-Pieces">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Anzahl der Partien mit Schwarz.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Koya">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Koya-Wertung.
										Summe der Punkte von Gegnern, die mehr als x 
										Prozent der Punkte eingefahren haben.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Direct-Encounter">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Direkter Vergleich.
										Sind mehrere Spieler nach den vorigen Wertungen
										gleichauf, zählen nur die Punkte des direkten Vergleichs.
										Darf nicht als Erstwertung gesetzt werden.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Average-Rating">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Durchschnittliche Wertungszahlen der Gegner.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Random">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Auslosen.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Custom">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Eigene Feinwertung.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="rounds-ranking-criterion-Buchholz">
		<xs:complexContent>
			<xs:extension base="rounds-ranking-criterion">
				<xs:sequence>
					<xs:sequence minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Anzahl der Streichwertungen. 
								Kann weggelassen oder auf 0 gesetzt werden für normale
								Buchholz-Wertung.
								Deckt "Buchholz" (0/0), "Median Buchholz" (1/1), "Median
								Buchholz 2" (2/2), "Buchholz Cut 1" (1/0), "Buchholz Cut
								2" (2/0) ab. 
							</xs:documentation>
						</xs:annotation>

						<xs:element name="lowest-cuts" type="xs:nonNegativeInteger" />
						<xs:element name="highest-cuts" type="xs:nonNegativeInteger" />
					</xs:sequence>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="rounds-ranking-criterion-Progressive-Score">
		<xs:complexContent>
			<xs:extension base="rounds-ranking-criterion">
				<xs:sequence>
					<xs:element name="cuts" minOccurs="0" type="xs:nonNegativeInteger" default="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Anzahl der Streichungen von Runden, beginnend bei 
								der 1. Runde (Standard: 0).
								Beispiel: Ist cuts=2, so werden von der 
								Fortschrittswertung eines Spielers seine Punktzahlen 
								nach der 1. und 2. Runde abgezogen.
							</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="rounds-ranking-criterion-Koya">
		<xs:complexContent>
			<xs:extension base="rounds-ranking-criterion">
				<xs:sequence>
					<xs:element name="percentage" minOccurs="0" default="50">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Prozentsatz, die Gegner mindestens an Punkten geholt
								haben müssen, um die Wertung einzufließen.
							</xs:documentation>
						</xs:annotation>

						<xs:simpleType>
							<xs:restriction base="xs:decimal">
								<xs:minExclusive value="0" />
								<xs:maxExclusive value="100" />
							</xs:restriction>
						</xs:simpleType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="rounds-ranking-criterion-Direct-Encounter">
		<xs:complexContent>
			<xs:extension base="rounds-ranking-criterion">
				<xs:sequence>
					<xs:element name="sub-criteria" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Feinwertungen für den direkten Vergleich, falls mehrere
								Spieler untersucht werden.
								Es sind nur "Wins" und "Black-Pieces" erlaubt.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:sequence>
								<xs:element name="criterion" type="rounds-ranking-criterion" maxOccurs="2" />
							</xs:sequence>

							<xs:assert test="every $c in criterion/@type satisfies (
																	not(empty(index-of(('Wins', 'Black-Pieces'), xs:string($c))))
																)" xerces:message="@type must be either 'Wins' or 'Black-Pieces'.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										@type muss "Wins" oder "Black-Pieces" sein.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="rounds-ranking-criterion-Average-Rating">
		<xs:complexContent>
			<xs:extension base="rounds-ranking-criterion">
				<xs:choice>
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Es kann entweder genau ein Rating-Type angegeben werden oder
							mehrere, von denen der Minimal- oder Maximalwert genutzt wird.
						</xs:documentation>
					</xs:annotation>

					<xs:element name="rating-type" type="rating-system">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Angabe genau eines Rating-Types.
							</xs:documentation>
						</xs:annotation>
					</xs:element>

					<xs:element name="rating-types" type="ranking-criterion-Rating-multiples">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Angabe mehrerer Rating-Types, deren Minimal- oder Maximalwert
								oder erster Wert ungleich null genutzt wird.
							</xs:documentation>
						</xs:annotation>

						<xs:alternative test="@get eq 'order'" type="ranking-criterion-Rating-multiples_ordered">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Angabe der Rating-Types in einer Reihenfolge, deren erster
									Wert ungleich null angenommen wird.
								</xs:documentation>
							</xs:annotation>
						</xs:alternative>

						<xs:alternative test="true()" type="ranking-criterion-Rating-multiples_minmax">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Angabe der Rating-Types ohne Reihenfolge, Minimal-
									oder Maximalwert wird angenommen.
								</xs:documentation>
							</xs:annotation>
						</xs:alternative>


						<xs:unique name="rounds-ranking-criterion-Average-Rating_unique-rating-types">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Die angegebenen Rating-Types dürfen nur einfach auftreten.
								</xs:documentation>
							</xs:annotation>

							<xs:selector xpath="rating-type" />
							<xs:field xpath="." />
						</xs:unique>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="rounds-ranking-criterion-Average-Custom">
		<xs:complexContent>
			<xs:extension base="rounds-ranking-criterion">
				<xs:sequence>
					<xs:element name="name">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Name der selbstdefinierten Feinwertung.
								Pflichtangabe.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:simpleContent>
								<xs:extension base="xs:string">
									<xs:attribute name="abbreviation" type="xs:string" use="optional">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Abkürzung der Feinwertung, etwa zur Angabe in Tabellen.
												Optional.
											</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:extension>
							</xs:simpleContent>
						</xs:complexType>
					</xs:element>

					<xs:element name="type" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Angabe, was für Werte angenommen werden können: "numeric", "alphanumeric", "alphabetic".
								Optional.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:simpleContent>
								<xs:extension base="criterion-Custom-type-values">
									<xs:attribute name="order" type="order" use="optional">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Angabe der Reihenfolge der geführten Wertungen: 
												"ascending" bedeutet, dass Spieler mit kleineren Werten höher
												platziert sind als solche mit höheren; "descending" umgekehrt.
											</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:extension>
							</xs:simpleContent>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="_t_rounds-ranking-criterion">
		<xs:complexContent>
			<xs:extension base="ranking-criterion">
				<xs:attribute name="type">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="Game-Points">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Einzelpunkte.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Match-Points">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Mannschaftspunkte.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Negative-Match-Points">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Negative Mannschaftspunkte. Summe der Match-Points und
										Negative-Match-Points muss nicht konstant sein, falls etwa
										nur 50% zum Erreichen eines Match-Points genügen und ein Ergebnis
										3.5:3.5 an acht Brettern entsteht (hier: Match-Points 0,
										Negative-Match-Points 0).
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Buchholz">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Buchholz.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Sonneborn-Berger">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Sonneborn-Berger.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Direct-Encounter">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Direkter Vergleich.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Berlin-System">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Berliner Wertung.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Random">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Auslosen.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>

							<xs:enumeration value="Custom">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Eigene Feinwertung.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="_t_rounds-ranking-criterion-Buchholz">
		<xs:complexContent>
			<xs:extension base="_t_rounds-ranking-criterion">
				<xs:sequence>
					<xs:sequence minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Anzahl der Streichwertungen. 
								Kann weggelassen oder auf 0 gesetzt werden für normale
								Buchholz-Wertung.
								Deckt "Buchholz" (0/0), "Median Buchholz" (1/1), "Median
								Buchholz 2" (2/2), "Buchholz Cut 1" (1/0), "Buchholz Cut
								2" (2/0) ab. 
							</xs:documentation>
						</xs:annotation>

						<xs:element name="lowest-cuts" type="xs:nonNegativeInteger" />
						<xs:element name="highest-cuts" type="xs:nonNegativeInteger" />
					</xs:sequence>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="_t_rounds-ranking-criterion-Custom">
		<xs:complexContent>
			<xs:extension base="_t_rounds-ranking-criterion">
				<xs:sequence>
					<xs:element name="name">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Name der selbstdefinierten Feinwertung.
								Pflichtangabe.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:simpleContent>
								<xs:extension base="xs:string">
									<xs:attribute name="abbreviation" type="xs:string" use="optional">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Abkürzung der Feinwertung, etwa zur Angabe in Tabellen.
												Optional.
											</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:extension>
							</xs:simpleContent>
						</xs:complexType>
					</xs:element>

					<xs:element name="type" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Angabe, was für Werte angenommen werden können: "numeric", "alphanumeric", "alphabetic".
								Optional.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:simpleContent>
								<xs:extension base="criterion-Custom-type-values">
									<xs:attribute name="order" type="order" use="optional">
										<xs:annotation>
											<xs:documentation xml:lang="DE">
												Angabe der Reihenfolge die geführten Wertungen: 
												"ascending" bedeutet, dass Spieler mit kleineren Werten höher
												platziert sind als solche mit höheren; "descending" umgekehrt.
											</xs:documentation>
										</xs:annotation>
									</xs:attribute>
								</xs:extension>
							</xs:simpleContent>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="_t_rounds-ranking-criterion-Direct-Encounter">
		<xs:complexContent>
			<xs:extension base="_t_rounds-ranking-criterion">
				<xs:sequence>
					<xs:element name="sub-criteria" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Feinwertungen für den direkten Vergleich, falls mehrere
								Mannschaften untersucht werden.
								Es sind nur "Game-Points", "Match-Points" und "Sonneborn-Berger" erlaubt.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:sequence>
								<xs:element name="criterion" type="_t_rounds-ranking-criterion" maxOccurs="3" />
							</xs:sequence>

							<xs:assert test="every $c in criterion/@type satisfies (
																	not(empty(index-of(('Game-Points', 'Match-Points', 'Sonneborn-Berger'), xs:string($c))))
																)" xerces:message="@type must be either 'Game-Points', 'Match-Points' or 'Sonneborn-Berger'.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										@type muss "Game-Points", "Match-Points" oder "Sonneborn-Berger" sein.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="individual-rounds-ranking-criteria">
		<xs:sequence>
			<xs:element name="criterion" type="rounds-ranking-criterion" maxOccurs="unbounded">
				<xs:alternative test="@type eq 'Buchholz'" type="rounds-ranking-criterion-Buchholz" />
				<xs:alternative test="@type eq 'Progressive-Score'" type="rounds-ranking-criterion-Progressive-Score" />
				<xs:alternative test="@type eq 'Koya'" type="rounds-ranking-criterion-Koya" />
				<xs:alternative test="@type eq 'Direct-Encounter'" type="rounds-ranking-criterion-Direct-Encounter" />
				<xs:alternative test="@type eq 'Average-Rating'" type="rounds-ranking-criterion-Average-Rating" />
				<xs:alternative test="@type eq 'Custom'" type="rounds-ranking-criterion-Average-Custom" />

				<xs:alternative test="true()" type="rounds-ranking-criterion" />
			</xs:element>
		</xs:sequence>


		<xs:assert test="count(criterion[1][@type eq 'Direct-Encounter']) eq 0" xerces:message="'Direct-Encounter' must not be the first criterion in the ranking settings.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					"Direkter Vergleich" darf nicht das erste Kriterium sein.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="every $i in 1 to count(criterion) satisfies (criterion[$i]/@number eq $i)" xerces:message="Criteria must be serially numbered, beginning with 1.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Die Kriterien müssen über ihr @number Attribut aufsteigend
					nummeriert sein, beginnend bei 1.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>

		<xs:assert test="empty(criterion[@type eq 'Random']) or criterion[@type eq 'Random']/@number eq criterion[position() eq last()]/@number" xerces:message="Criterion 'Random' could only be the last one.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					"Random" kann nur das letzte Kriterium sein.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>
	</xs:complexType>


	<xs:complexType name="_s_ranking-round">
		<xs:complexContent>
			<xs:extension base="ranking-round">
				<xs:sequence>
					<xs:element name="player" type="ranking-row" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Die Feinwertungen des Spielers können als Entität
								in Listenform erfasst werden. Die Liste kann aber auch
								leer sein.
								Das @position Attribut muss nicht eindeutig sein, da
								mehrere Spieler auf dem gleichen Platz landen können.
							</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>


				<xs:assert test="count(player[@position eq 1]) ge 1" xerces:message="The ranking must contain at least one player with @position = 1.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Die Rangliste muss mindestens einen Spieler mit
							@position = 1 beinhalten.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="every $i in 1 to (count(player)-1) satisfies (
										player[$i]/@position eq player[$i+1]/@position or player[$i+1]/@position eq ($i+1)
									)" xerces:message="player[$i]/@position is either index $i or player[$i-1]/@position in case of identical positions.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Angegebene player[$i]/@position entspricht entweder dem Index $i 
							oder ist gleich player[$i-1]/@position im Falle der gleichen
							Platzierung.
							Bsp: 1,1,3,4 ist valide; 1,1,3,5 und 1,1,2,3 jedoch nicht.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="_t_ranking-round">
		<xs:complexContent>
			<xs:extension base="ranking-round">
				<xs:sequence>
					<xs:element name="teams">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Mannschafts-Rangliste.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:sequence>
								<xs:element name="team" type="ranking-row" maxOccurs="unbounded">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Die Feinwertungen der Mannschaften können als Entität
											in Listenform erfasst werden. Die Liste kann aber auch
											leer sein.
											Das @position Attribut muss nicht eindeutig sein, da
											mehrere Mannschaften auf dem gleichen Platz landen können.
										</xs:documentation>
									</xs:annotation>
								</xs:element>
							</xs:sequence>


							<xs:assert test="count(team[@position eq 1]) ge 1" xerces:message="The ranking must contain at least one team with @position = 1.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Die Rangliste muss mindestens eine Mannschaft mit
										@position = 1 beinhalten.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>

							<xs:assert test="every $i in 1 to (count(team)-1) satisfies (
													team[$i]/@position eq team[$i+1]/@position or team[$i+1]/@position eq ($i+1)
												)" xerces:message="Every team[$i]/@position must be either index $i or team[$i-1]/@position in case of identical positions.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Angegebene team[$i]/@position entspricht entweder dem Index $i
										oder ist gleich team[$i-1]/@position im Falle der gleichen
										Platzierung.
										Bsp: 1,1,3,4 ist valide; 1,1,3,5 und 1,1,2,3 jedoch nicht.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>
						</xs:complexType>
					</xs:element>

					<xs:element name="players" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Rangliste der Einzelspieler, unabhängig von Brett
								oder Mannschaft.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:sequence>
								<xs:element name="player" type="ranking-row" maxOccurs="unbounded">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Die Feinwertungen der Spieler können als Entität
											in Listenform erfasst werden. Die Liste kann aber auch
											leer sein.
											Das @position Attribut muss nicht eindeutig sein, da
											mehrere Spieler auf dem gleichen Platz landen können.
										</xs:documentation>
									</xs:annotation>
								</xs:element>
							</xs:sequence>


							<xs:assert test="count(player[@position eq 1]) ge 1" xerces:message="The ranking must contain at least one player with @position = 1.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Die Rangliste muss mindestens einen Spieler mit
										@position = 1 beinhalten.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>

							<xs:assert test="every $i in 1 to (count(player)-1) satisfies (
													player[$i]/@position eq player[$i+1]/@position or player[$i+1]/@position eq ($i+1)
												)" xerces:message="Every player[$i]/@position must be either index $i or player[$i-1]/@position in case of identical positions.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Angegebene player[$i]/@position entspricht entweder dem Index $i
										oder ist gleich player[$i-1]/@position im Falle der gleichen
										Platzierung.
										Bsp: 1,1,3,4 ist valide; 1,1,3,5 und 1,1,2,3 jedoch nicht.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>
						</xs:complexType>																	
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="notes">
		<xs:sequence>
			<xs:element name="note" minOccurs="0">
				<xs:complexType>
					<xs:simpleContent>
						<xs:extension base="xs:string">
							<xs:attribute name="date" type="xs:dateTime" use="optional">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Zeitstempel der letzten Änderung.
									</xs:documentation>
								</xs:annotation>
							</xs:attribute>

							<xs:attribute name="public" type="xs:boolean" use="optional" default="false">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Flag, ob die Info öffentlich ist. Notes mit @public='true' könnten etwa
										auf den Paarungsaushängen veröffentlicht werden.
									</xs:documentation>
								</xs:annotation>
							</xs:attribute>
						</xs:extension>
					</xs:simpleContent>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>


	<xs:complexType name="_s_round">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Runde. Beinhaltet mindestens information oder boards, 
				ist aber in keinem Fall leer.
			</xs:documentation>
		</xs:annotation>

		<xs:sequence>
			<xs:element name="information" type="pairing-information-single" minOccurs="0" />

			<xs:element name="notes" type="notes" minOccurs="0" />

			<xs:element name="boards" minOccurs="0">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="board" type="_interface-board-general" maxOccurs="unbounded">
							<xs:alternative test="@attribute eq 'bye'" type="board-bye" />
							<xs:alternative test="true()" type="board_single" />
						</xs:element>
					</xs:sequence>


					<xs:assert test="every $i in 1 to count(board) satisfies (board[$i]/@number = $i)" xerces:message="Board numbers must be serially numbered, beginning with 1.">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Brettnummern müssen aufsteigend durchnummeriert sein, beginnend bei 1.
							</xs:documentation>
						</xs:annotation>
					</xs:assert>

					<xs:assert test="every $i in (board/white/@player | board/black/@player) satisfies 
										(count((board/white | board/black)[@player = $i]) eq 1)" xerces:message="Every player can be paired only once per round.">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Spieler darf pro Runde nur einmal gepaart sein.
							</xs:documentation>
						</xs:annotation>
					</xs:assert>
				</xs:complexType>
			</xs:element>
		</xs:sequence>

		<xs:attribute name="number" type="xs:positiveInteger" use="required" />
	</xs:complexType>


	<xs:complexType name="_t_round">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Runde. Beinhaltet mindestens information oder tables, 
				ist aber in keinem Fall leer.
			</xs:documentation>
		</xs:annotation>

		<xs:sequence>
			<xs:element name="information" minOccurs="0" type="pairing-information-team" />

			<xs:element name="notes" type="notes" minOccurs="0" />

			<xs:element name="tables" minOccurs="0" maxOccurs="1">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Beinhaltet mindestens ein table-Element.
					</xs:documentation>
				</xs:annotation>

				<xs:complexType>
					<xs:sequence>
						<xs:element name="table" type="_t_interface_table" minOccurs="1" maxOccurs="unbounded">
							<xs:alternative test="@attribute eq 'bye'" type="_t_table-bye" />
							<xs:alternative test="true()" type="_t_table" />
						</xs:element>
					</xs:sequence>

					<xs:assert test="every $i in (table/team/@id) satisfies 
										(count(table/team[@id = $i]) le 1)" xerces:message="Every team can be paired only once per round.">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Bedingung (XSD1.0 kompatibel): Team darf pro Runde
								nur einmal gepaart sein.
							</xs:documentation>
						</xs:annotation>
					</xs:assert>
				</xs:complexType>
			</xs:element>
		</xs:sequence>

		<xs:attribute name="number" type="xs:positiveInteger" use="required" />
	</xs:complexType>


	<xs:simpleType name="_t_table-attribute">
		<xs:restriction base="xs:string">
			<xs:enumeration value="" />

			<xs:enumeration value="bye">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Spielfrei, Freilos.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>


	<xs:complexType name="_t_interface_table">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Oberklasse für _t_table-bye und _t_board, sollte nicht
				direkt benutzt werden.
			</xs:documentation>
		</xs:annotation>

		<xs:attribute name="attribute" type="_t_table-attribute" use="optional" default="" />
		<xs:attribute name="number" type="xs:positiveInteger" use="required" />
	</xs:complexType>


	<xs:complexType name="_t_table-bye">
		<xs:complexContent>
			<xs:extension base="_t_interface_table">
				<xs:sequence>
					<xs:element name="team">
						<xs:complexType>
							<xs:attribute name="id" type="xs:positiveInteger" />
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="_t_table">
		<xs:complexContent>
			<xs:extension base="_t_interface_table">
				<xs:sequence>
					<xs:sequence>
						<xs:element name="team" minOccurs="1" maxOccurs="2">
							<xs:complexType>
								<xs:attribute name="id" use="required" type="xs:positiveInteger" />

								<xs:attribute name="position" use="required">
									<xs:simpleType>
										<xs:restriction base="xs:positiveInteger">
											<xs:enumeration value="1" />
											<xs:enumeration value="2" />
										</xs:restriction>
									</xs:simpleType>
								</xs:attribute>
							</xs:complexType>
						</xs:element>
					</xs:sequence>

					<xs:choice minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Entweder Angabe aller Einzelpaarungen (d.h. welcher
								Spieler gegen welchen spielte) über "boards" oder 
								Anzahl der erzielten Ergebnisse über "results".
							</xs:documentation>
						</xs:annotation>

						<xs:element name="results" maxOccurs="2">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Auflistung der erzielten Einzelergebnisse.
								</xs:documentation>
							</xs:annotation>

							<xs:complexType>
								<xs:sequence>
									<xs:element name="team" minOccurs="2" maxOccurs="2">
										<xs:complexType>
											<xs:sequence>
												<xs:element name="wins" type="single-result-summarization" minOccurs="0" maxOccurs="unbounded" />
												<xs:element name="draws" type="single-result-summarization" minOccurs="0" maxOccurs="unbounded" />
												<xs:element name="losses" type="single-result-summarization" minOccurs="0" maxOccurs="unbounded" />
											</xs:sequence>

											<xs:attribute name="position" use="required">
												<xs:simpleType>
													<xs:restriction base="xs:positiveInteger">
														<xs:enumeration value="1" />
														<xs:enumeration value="2" />
													</xs:restriction>
												</xs:simpleType>
											</xs:attribute>
										</xs:complexType>


										<xs:unique name="unique-result-entry_wins">
											<xs:selector xpath="wins" />
											<xs:field xpath="@attribute" />
										</xs:unique>
										<xs:unique name="unique-result-entry_draws">
											<xs:selector xpath="draws" />
											<xs:field xpath="@attribute" />
										</xs:unique>
										<xs:unique name="unique-result-entry_losses">
											<xs:selector xpath="losses" />
											<xs:field xpath="@attribute" />
										</xs:unique>
									</xs:element>
								</xs:sequence>

								<xs:attribute name="overruled" type="xs:boolean" use="optional" default="false">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Nicht mehr gültiges Resultat, da von Instanz (Turnierleitung, 
											Staffelleitung, Schiedsgericht, ...) aufgehoben.
											Im Falle einer solchen Entscheidung ist das tatsächlich
											gespielte Ergebnis mit diesem Attribut versehen.
										</xs:documentation>
									</xs:annotation>
								</xs:attribute>
							</xs:complexType>
						</xs:element>

						<xs:element name="boards">
							<xs:annotation>
								<xs:documentation xml:lang="DE">
									Einzelpaarungen der Mannschaftsspieler
								</xs:documentation>
							</xs:annotation>

							<xs:complexType>
								<xs:sequence>
									<xs:element name="board" type="_interface-board-general" maxOccurs="unbounded">
										<xs:alternative test="@attribute eq 'bye'" type="board-bye" />
										<xs:alternative test="true()" type="_t_board" />
									</xs:element>
								</xs:sequence>

								<xs:assert test="every $i in 1 to count(board) satisfies (board[$i]/@number = $i)" xerces:message="Board numbers must be serially numbered, beginning with 1.">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Brettnummern müssen aufsteigend durchnummeriert sein, beginnend bei 1.
										</xs:documentation>
									</xs:annotation>
								</xs:assert>
							</xs:complexType>
						</xs:element>
					</xs:choice>

					<xs:element name="information" minOccurs="0" type="pairing-information-team">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Zusätzliche Informationen zu dieser Paarung zweier Mannschaften,
								optional.
							</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>


				<xs:attribute name="swapped" type="xs:boolean" use="optional" default="false">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Flag, ob die Begegnung mit vertauschen Farben aufgenommen wurde, d.h. Heim-
							und Auswärtsrecht vertauscht wurden. Gespeichert
							wird immer die ursprünglich ausgeloste Farbverteilung, sodass über 
							@swapped='true' die Vertauschung kenntlich gemacht werden kann.
							Die Einzelpaarungen müssen in diesem Fall nicht mit dem @swapped-Attribut
							markiert werden, d.h. wenn dann auch alle Einzelspieler mit vertauschten
							Farben (also wirklich nur Heim/Auswärts komplett vertauscht wurde) gespielt
							haben, erhält nur die Teampaarung das @swapped-Attribut.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>

				<xs:assert test="if (count(results) ge 1) then (count(results[not(xs:boolean(@overruled))]) eq 1) else true()" xerces:message="There must be exactly one result with @overrule='false'.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Falls die Ergebnisse über die results-Methode erfasst werden, darf nur
							genau eines gültig sein, d.h. @overrule='false' sein.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="every $team in (boards/board/white/@team | boards/board/black/@team | boards/board/player/@team) satisfies (
											count(team[@id eq $team]) eq 1
										)" xerces:message="The players listed in the single-player-pairings must be of one of the competing teams.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Es dürfen in den Einzelpaarungen nur Spieler aufgeführt werden, die 
							einer der beiden Mannschaften dieser Begegnung angehören.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>

				<xs:assert test="every $id in (boards/board/white/@player | boards/board/black/@player) satisfies (
											count(boards/board/white[@player = $id] | boards/board/black[@player = $id]) eq 1
										)" xerces:message="Every player can be listed only once per table.">
					<xs:annotation>
						<xs:documentation xml:lang="DE">
							Ein Spieler kann in einer Begegnung nur einmal aufgeführt werden.
						</xs:documentation>
					</xs:annotation>
				</xs:assert>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:simpleType name="pairings-system-name">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Name des Auslosungssystems, möglich sowohl in Einzel-
				als auch Mannschaftsturnieren.
			</xs:documentation>
		</xs:annotation>

		<xs:restriction base="xs:string">
			<xs:enumeration value="Swiss">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Schweizer System.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>

			<xs:enumeration value="Round-Robin">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Rundenturnier.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>

			<xs:enumeration value="Knockout">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						KO-Turnier.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>


	<xs:complexType name="_s_pairings-system">
		<xs:sequence />

		<xs:attribute name="type" use="required">
			<xs:simpleType>
				<xs:union memberTypes="pairings-system-name" />
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="_s_pairings-system-Swiss">
		<xs:complexContent>
			<xs:extension base="_s_pairings-system">
				<xs:sequence>
					<xs:element name="colors" minOccurs="0">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="first-in-first-round" minOccurs="0">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Farbe des Spielers mit Startrangnummer 1 in der ersten
											Runde.
										</xs:documentation>
									</xs:annotation>

									<xs:simpleType>
										<xs:restriction base="xs:string">
											<xs:enumeration value="white" />
											<xs:enumeration value="black" />

											<xs:enumeration value="random">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Ausgelost.
													</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
										</xs:restriction>
									</xs:simpleType>
								</xs:element>

								<xs:element name="max-difference" type="xs:positiveInteger" minOccurs="0">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Höchstzulässige Differenz zwischen beiden Farben, ehe ein Farbwechsel
											strikt erforderlich wird.
											Bei Angabe des Minimalwertes "1" ist neben der rein abwechselnden 
											Farbverteilung etwa auch die Verteilung "wbbw" möglich.
										</xs:documentation>
									</xs:annotation>
								</xs:element>

								<xs:element name="max-series" type="xs:positiveInteger" minOccurs="0">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Maximale Anzahl an aufeinanderfolgenden Runden mit der
											gleichen Farbe. "1" bedeutet somit strikt abwechselnd.
										</xs:documentation>
									</xs:annotation>
								</xs:element>
							</xs:sequence>


							<xs:assert test="count(./*) gt 0" xerces:message="There must be at least one child element in /tournament/settings/pairings[@type = 'Swiss']/colors." />
						</xs:complexType>
					</xs:element>

					<xs:element name="re-pair-by-default-games" type="xs:boolean" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Flag, ob Spieler, deren Begegnung bereits kampflos zuende ging,
								noch einmal gegeneinander gepaart werden dürfen.
							</xs:documentation>
						</xs:annotation>
					</xs:element>

					<xs:element name="pairing-groups" minOccurs="0">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="accelerated" minOccurs="0">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Beschleunigtes Paaren.
										</xs:documentation>
									</xs:annotation>

									<xs:complexType>
										<xs:sequence>
											<xs:element name="groups">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Anzahl der Gruppen, die für die erste Runde gebildet
														werden sollen.
													</xs:documentation>
												</xs:annotation>

												<xs:simpleType>
													<xs:restriction base="xs:positiveInteger">
														<xs:minInclusive value="2" />
													</xs:restriction>
												</xs:simpleType>
											</xs:element>
										</xs:sequence>
									</xs:complexType>
								</xs:element>

								<xs:element name="max-group-size" minOccurs="0">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Maximale Gruppengröße.
										</xs:documentation>
									</xs:annotation>

									<xs:simpleType>
										<xs:restriction base="xs:positiveInteger">
											<xs:minInclusive value="4" />

											<xs:assertion test="$value mod 2 eq 0" />
										</xs:restriction>
									</xs:simpleType>
								</xs:element>
							</xs:sequence>


							<xs:assert test="count(./*) gt 0" xerces:message="The node /tournament/settings/pairings/system[@type = 'Swiss']/pairing-groups must not be empty.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Das /tournament/settings/pairings/system[@type = 'Swiss']/pairing-groups
										Element beinhaltet mindestens ein Kindelement.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>
						</xs:complexType>
					</xs:element>

					<xs:element name="pairing-constraints" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Angabe von Nebenbedingungen, die bei der Bildung der Paarungen
								berücksichtigt werden müssen und die konkreten 
								Bildungsvorschriften darstellen oder beeinflussen (anders als
								die Angaben aus /tournament/settings/pairings/constraints,
								welche nur die konkreten Brettnummern oder das Aussetzen
								einzelner bewirken).
								Die Bedingungen sind in absteigender Priorität aufgelistet,
								d.h. sollten sich unter Berücksichtigung aller angegebenen
								Bedingungen keine Paarungen bilden lassen, wird das unterste,
								mit der höchsten @number, im nächsten Schritt nicht
								berücksichtigt, usw., bis sich Paarungen bilden lassen.
								Es ist möglich, die Gültigkeit von Bedingungen auf einzelne
								Runden zu beschränken.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:sequence>
								<xs:element name="constraint" maxOccurs="unbounded">
									<xs:complexType>
										<xs:sequence>
											<xs:choice>
												<xs:element name="different" type="_s_pairing-constraints-selectable-fields" />
												<xs:element name="identical" type="_s_pairing-constraints-selectable-fields" />
											</xs:choice>

											<xs:element name="rounds" minOccurs="0">
												<xs:complexType>
													<xs:sequence>
														<xs:element name="round" type="xs:positiveInteger" maxOccurs="unbounded" />
													</xs:sequence>

													<xs:assert test="every $i in 1 to count(round)-1 satisfies (xs:integer(round[$i]) lt xs:integer(round[$i+1]))" xerces:message="Numbers in /tournament/settings/pairings/system[@type = 'Swiss']/pairing-constraints/constraint/rounds must be listet in ascending order.">
														<xs:annotation>
															<xs:documentation xml:lang="DE">
																Die Runden müssen aufsteigend sortiert sein.
															</xs:documentation>
														</xs:annotation>
													</xs:assert>
												</xs:complexType>
											</xs:element>
										</xs:sequence>

										<xs:attribute name="number" type="xs:positiveInteger" />
									</xs:complexType>
								</xs:element>
							</xs:sequence>

							<xs:assert test="every $i in 1 to count(constraint) satisfies (constraint[$i]/@number eq $i)" xerces:message="Constraints in /tournament/settings/pairings/system[@type = 'Swiss']/pairing-constraints must be serially numbered via their @number attribute, beginning with 1.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Die Constraints sind aufsteigend durchnummeriert,
										beginnend bei 1.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="_s_pairings-system-Round-Robin">
		<xs:complexContent>
			<xs:extension base="_s_pairings-system">
				<xs:sequence>
					<xs:element name="innings" type="xs:positiveInteger">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Anzahl der Durchgänge.
							</xs:documentation>
						</xs:annotation>
					</xs:element>

					<xs:element name="colors" minOccurs="0">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="first-in-first-round" type="color" minOccurs="0" />
							</xs:sequence>

							<xs:assert test="count(./*) gt 0" xerces:message="The element /tournament/settings/pairings/system[@type = 'Round-Robin']/colors must not be empty.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Das colors-Element muss mindestens ein Kindelement
										besitzen.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>
						</xs:complexType>
					</xs:element>

					<xs:element name="scheduling-algorithm" type="Round-Robin-scheduling-algorithm" minOccurs="0" />
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="_t_pairings-system">
		<xs:sequence />

		<xs:attribute name="type" use="required">
			<xs:simpleType>
				<xs:union memberTypes="pairings-system-name" />
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>

	<xs:complexType name="_t_pairings-system-Swiss">
		<xs:complexContent>
			<xs:extension base="_t_pairings-system">
				<xs:sequence>
					<xs:element name="positions" minOccurs="0">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="first-in-first-round" minOccurs="0">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Position der Mannschaft mit Startrangnummer 1 in der ersten
											Runde. Entspricht colors/first-in-first-round bei Einzelturnieren.
											Pflichtangabe.
										</xs:documentation>
									</xs:annotation>

									<xs:simpleType>
										<xs:restriction base="xs:string">
											<xs:enumeration value="1" />
											<xs:enumeration value="2" />

											<xs:enumeration value="random">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Ausgelost.
													</xs:documentation>
												</xs:annotation>
											</xs:enumeration>
										</xs:restriction>
									</xs:simpleType>
								</xs:element>

								<xs:element name="max-difference" type="xs:positiveInteger" minOccurs="0">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Höchstzulässige Differenz zwischen beiden Positionen, ehe ein "Farbwechsel"
											strikt erforderlich wird.
											Bei Angabe des Minimalwertes "1" ist neben der rein abwechselnden 
											Farbverteilung etwa auch die Verteilung "1 2 2 1" möglich.
										</xs:documentation>
									</xs:annotation>
								</xs:element>

								<xs:element name="max-series" type="xs:positiveInteger" minOccurs="0">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Maximale Anzahl an aufeinanderfolgenden Runden mit der
											gleichen Farbe. "1" bedeutet somit strikt abwechselnd.
										</xs:documentation>
									</xs:annotation>
								</xs:element>
							</xs:sequence>

							<xs:assert test="count(./*) gt 0" xerces:message="There must be at least one child element in /tournament/settings/pairings[@type = 'Swiss']/positions." />
						</xs:complexType>
					</xs:element>

					<xs:element name="re-pair-by-default-pairings" type="xs:boolean" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Flag, ob Mannschaften, deren Begegnung bereits kampflos zuende ging,
								noch einmal gegeneinander gepaart werden dürfen.
							</xs:documentation>
						</xs:annotation>
					</xs:element>

					<xs:element name="pairing-groups" minOccurs="0">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="accelerated" minOccurs="0">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Beschleunigtes Paaren.
										</xs:documentation>
									</xs:annotation>

									<xs:complexType>
										<xs:sequence>
											<xs:element name="groups">
												<xs:annotation>
													<xs:documentation xml:lang="DE">
														Anzahl der Gruppen, die für die erste Runde gebildet
														werden sollen.
													</xs:documentation>
												</xs:annotation>

												<xs:simpleType>
													<xs:restriction base="xs:positiveInteger">
														<xs:minInclusive value="2" />
													</xs:restriction>
												</xs:simpleType>
											</xs:element>
										</xs:sequence>
									</xs:complexType>
								</xs:element>

								<xs:element name="max-group-size" minOccurs="0">
									<xs:annotation>
										<xs:documentation xml:lang="DE">
											Maximale Gruppengröße.
										</xs:documentation>
									</xs:annotation>

									<xs:simpleType>
										<xs:restriction base="xs:positiveInteger">
											<xs:minInclusive value="4" />

											<xs:assertion test="$value mod 2 eq 0" />
										</xs:restriction>
									</xs:simpleType>
								</xs:element>
							</xs:sequence>


							<xs:assert test="count(./*) gt 0" xerces:message="The node /tournament/settings/pairings/system[@type = 'Swiss']/pairing-groups must not be empty.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Das /tournament/settings/pairings/system[@type = 'Swiss']/pairing-groups
										Element beinhaltet mindestens ein Kindelement.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>
						</xs:complexType>
					</xs:element>

					<xs:element name="pairing-constraints" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Angabe von Nebenbedingungen, die bei der Bildung der Paarungen
								berücksichtigt werden müssen und die konkreten 
								Bildungsvorschriften darstellen oder beeinflussen (anders als
								die Angaben aus /tournament/settings/pairings/constraints,
								welche nur die konkreten Brettnummern oder das Aussetzen
								einzelner bewirken).
								Die Bedingungen sind in absteigender Priorität aufgelistet,
								d.h. sollten sich unter Berücksichtigung aller angegebenen
								Bedingungen keine Paarungen bilden lassen, wird das unterste,
								mit der höchsten @number, im nächsten Schritt nicht
								berücksichtigt, usw., bis sich Paarungen bilden lassen.
								Es ist möglich, die Gültigkeit von Bedingungen auf einzelne
								Runden zu beschränken.
							</xs:documentation>
						</xs:annotation>

						<xs:complexType>
							<xs:sequence>
								<xs:element name="constraint" maxOccurs="unbounded">
									<xs:complexType>
										<xs:sequence>
											<xs:choice>
												<xs:element name="different" type="_t_pairing-constraints-selectable-fields" />
												<xs:element name="identical" type="_t_pairing-constraints-selectable-fields" />
											</xs:choice>

											<xs:element name="rounds" minOccurs="0">
												<xs:complexType>
													<xs:sequence>
														<xs:element name="round" type="xs:positiveInteger" maxOccurs="unbounded" />
													</xs:sequence>

													<xs:assert test="every $i in 1 to count(round)-1 satisfies (xs:integer(round[$i]) lt xs:integer(round[$i+1]))" xerces:message="Numbers in /tournament/settings/pairings/system[@type = 'Swiss']/pairing-constraints/constraint/rounds must be listet in ascending order.">
														<xs:annotation>
															<xs:documentation xml:lang="DE">
																Die Runden müssen aufsteigend sortiert sein.
															</xs:documentation>
														</xs:annotation>
													</xs:assert>
												</xs:complexType>
											</xs:element>
										</xs:sequence>

										<xs:attribute name="number" type="xs:positiveInteger" />
									</xs:complexType>
								</xs:element>
							</xs:sequence>

							<xs:assert test="every $i in 1 to count(constraint) satisfies (constraint[$i]/@number eq $i)" xerces:message="Constraints in /tournament/settings/pairings/system[@type = 'Swiss']/pairing-constraints must be serially numbered via their @number attribute, beginning with 1.">
								<xs:annotation>
									<xs:documentation xml:lang="DE">
										Die Constraints sind aufsteigend durchnummeriert,
										beginnend bei 1.
									</xs:documentation>
								</xs:annotation>
							</xs:assert>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="_t_pairings-system-Round-Robin">
		<xs:complexContent>
			<xs:extension base="_t_pairings-system">
				<xs:sequence>
					<xs:element name="innings" type="xs:positiveInteger">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Anzahl der Durchgänge.
							</xs:documentation>
						</xs:annotation>
					</xs:element>

					<xs:element name="scheduling-algorithm" type="Round-Robin-scheduling-algorithm" minOccurs="0" />
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:simpleType name="_t_number-of-boards">
		<xs:restriction base="xs:positiveInteger">
			<xs:minInclusive value="2" />
		</xs:restriction>
	</xs:simpleType>


	<xs:simpleType name="player-origin-type">
		<xs:annotation>
			<xs:documentation xml:lang="DE">
				Aufzählung möglicher Attribute für
				/tournament/players/player/origin/@type
			</xs:documentation>
		</xs:annotation>

		<xs:restriction base="xs:string">
			<xs:enumeration value="school" />
			<xs:enumeration value="city" />
		</xs:restriction>
	</xs:simpleType>


	<xs:simpleType name="Country-Code">
		<xs:union memberTypes="IOC-Country-Code ISO3166-Country-Code Special-Federation-Code" />
	</xs:simpleType>

	<xs:simpleType name="Special-Federation-Code">
		<xs:restriction base="xs:string">
			<xs:enumeration value="IBCA" /> <!-- International Braille Chess Association -->
			<xs:enumeration value="ICSC" /> <!-- International Committee of Silent Chess -->
			<xs:enumeration value="IPCA" /> <!-- International Physically Disabled Chess Association -->
		</xs:restriction>
	</xs:simpleType>


	<xs:complexType name="identifier-club">
		<xs:sequence>
			<xs:element name="name">
				<xs:annotation>
					<xs:documentation xml:lang="DE">
						Vereinsname. Als einziges Kindelement Pflichtangabe.
						Freitext, mindestens drei Zeichen lang.
					</xs:documentation>
				</xs:annotation>

				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:minLength value="3" />
					</xs:restriction>
				</xs:simpleType>
			</xs:element>
		</xs:sequence>

		<xs:attribute name="federation" type="Country-Code" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Herkunftsland des Vereins. Muss angegeben werden,
					falls club/id ebenfalls angegeben wurde.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>

		<xs:assert test="@federation or not(id)" xerces:message="Attribute @federation must be set for clubs with given club/id.">
			<xs:annotation>
				<xs:documentation xml:lang="DE">
					Wenn die club/id eines Vereins angegeben ist, muss auch
					das club/@federation Attribut gesetzt sein.
				</xs:documentation>
			</xs:annotation>
		</xs:assert>
	</xs:complexType>


	<xs:complexType name="_t_team-identifier-club_abstract">
		<xs:complexContent>
			<xs:extension base="identifier-club">
				<xs:sequence>
					<xs:element name="team-number" type="xs:positiveInteger" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="DE">
								Mannschaftsnummer, falls mehrere Mannschaften eines
								Vereins antreten.
								Optional.
							</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>	


	<xs:complexType name="_t_team-identifier-club">
		<xs:complexContent>
			<xs:extension base="_t_team-identifier-club_abstract">
				<xs:sequence>
					<xs:element name="id" minOccurs="0">
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:minLength value="1" />
							</xs:restriction>
						</xs:simpleType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="_t_team-identifier-club_GER">
		<xs:complexContent>
			<xs:extension base="_t_team-identifier-club_abstract">
				<xs:sequence>
					<xs:element name="id" type="club-id_GER" minOccurs="0" />
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:complexType name="player-identifier-club">
		<xs:complexContent>
			<xs:extension base="identifier-club">
				<xs:sequence>
					<xs:sequence minOccurs="0">
						<xs:element name="id">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:minLength value="1" />
								</xs:restriction>
							</xs:simpleType>
						</xs:element>

						<xs:element name="member-id" minOccurs="0">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:minLength value="1" />
								</xs:restriction>
							</xs:simpleType>
						</xs:element>
					</xs:sequence>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="player-identifier-club_GER">
		<xs:complexContent>
			<xs:extension base="identifier-club">
				<xs:sequence>
					<xs:sequence minOccurs="0">
						<xs:element name="id" type="club-id_GER" />
						<xs:element name="member-id" type="member-id_GER" minOccurs="0" />
					</xs:sequence>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<xs:simpleType name="_s_pairing-constraints-selectable-fields">
		<xs:restriction base="xs:string">
			<xs:enumeration value="player/identifiers/club" />
		</xs:restriction>
	</xs:simpleType>

	<xs:simpleType name="_t_pairing-constraints-selectable-fields">
		<xs:restriction base="xs:string">
			<xs:enumeration value="team/identifiers/club" />
		</xs:restriction>
	</xs:simpleType>


	<xs:simpleType name="club-id_GER">
		<xs:restriction base="xs:string">
			<xs:pattern value="[0-9A-IK][0-9A-F]{2}[0-9]{2}" />
		</xs:restriction>
	</xs:simpleType>

	<xs:simpleType name="member-id_GER">
		<xs:restriction base="xs:nonNegativeInteger">
			<xs:maxExclusive value="10000" />
		</xs:restriction>
	</xs:simpleType>

	<xs:simpleType name="Round-Robin-scheduling-algorithm">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Standard" />
			<xs:enumeration value="Berger" />
		</xs:restriction>
	</xs:simpleType>
</xs:schema>
